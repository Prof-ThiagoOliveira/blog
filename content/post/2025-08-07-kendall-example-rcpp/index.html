---
title: "Benchmarking Kendall's Tau in R and Rcpp"
date:  "August 09, 2025"
slug: "benchmarking-kendalls-tau-r-rcpp"
categories:
  - "R Programming"
  - "Statistical Computing"
tags:
  - "Rcpp"
  - "C++"
  - "Kendall's tau"
  - "rank correlation"
  - "microbenchmarking"
  - "performance"
subtitle: "R vs Rcpp with a fast inversion-count implementation"
summary: "Implement and benchmark a fast Kendall's tau-a in C++ via Rcpp against base R, discuss tie handling (tau-b), and when to move from R to C++."
authors:
  - admin
lastmod: "2025-08-09T07:48:20Z"
featured: false
image:
  caption: ""
  focal_point: ""
  preview_only: false
projects: []
output:
  blogdown::html_page:
    toc: true
    number_sections: true
    toc_depth: 3
---


<div id="TOC">
<ul>
<li><a href="#overview" id="toc-overview"><span class="toc-section-number">1</span> Overview</a></li>
<li><a href="#setup" id="toc-setup"><span class="toc-section-number">2</span> Setup</a></li>
<li><a href="#kendalls-tau-definitions" id="toc-kendalls-tau-definitions"><span class="toc-section-number">3</span> Kendall‚Äôs tau definitions</a>
<ul>
<li><a href="#kendalls-tau_a-no-tie-correction" id="toc-kendalls-tau_a-no-tie-correction"><span class="toc-section-number">3.1</span> Kendall‚Äôs <span class="math inline">\(\tau_a\)</span> (no tie correction)</a></li>
<li><a href="#kendalls-tau_b-tie-adjusted" id="toc-kendalls-tau_b-tie-adjusted"><span class="toc-section-number">3.2</span> Kendall‚Äôs <span class="math inline">\(\tau_b\)</span> (tie-adjusted)</a></li>
<li><a href="#remarks-and-edge-cases" id="toc-remarks-and-edge-cases"><span class="toc-section-number">3.3</span> Remarks and edge cases</a></li>
</ul></li>
<li><a href="#implementation-in-r-rcpp" id="toc-implementation-in-r-rcpp"><span class="toc-section-number">4</span> Implementation in R (Rcpp)</a>
<ul>
<li><a href="#rcpp-inline-implementation-tau_a" id="toc-rcpp-inline-implementation-tau_a"><span class="toc-section-number">4.1</span> Rcpp inline implementation (<span class="math inline">\(\tau_a\)</span>)</a></li>
<li><a href="#rcpp-inline-implementation-tau-b" id="toc-rcpp-inline-implementation-tau-b"><span class="toc-section-number">4.2</span> Rcpp inline implementation (tau-b)</a></li>
</ul></li>
<li><a href="#sanity-checks-considering-tie-free-vs-tie-heavy-data" id="toc-sanity-checks-considering-tie-free-vs-tie-heavy-data"><span class="toc-section-number">5</span> Sanity checks considering tie-free vs tie-heavy data</a>
<ul>
<li><a href="#tie-free-continuous-data" id="toc-tie-free-continuous-data"><span class="toc-section-number">5.1</span> Tie-free (continuous) data</a></li>
<li><a href="#tie-heavy-data-we-have-tau_b-approx-base-r-tau_a-differs" id="toc-tie-heavy-data-we-have-tau_b-approx-base-r-tau_a-differs"><span class="toc-section-number">5.2</span> Tie-heavy data we have <span class="math inline">\(\tau_b \approx\)</span> base R, <span class="math inline">\(\tau_a\)</span> differs</a></li>
</ul></li>
<li><a href="#benchmark-design-microbenchmarks-no-ties-vs-many-ties" id="toc-benchmark-design-microbenchmarks-no-ties-vs-many-ties"><span class="toc-section-number">6</span> Benchmark design &amp; microbenchmarks (no ties vs many ties)</a>
<ul>
<li><a href="#microbenchmark-tie-free-data" id="toc-microbenchmark-tie-free-data"><span class="toc-section-number">6.0.1</span> Microbenchmark: tie-free data</a></li>
<li><a href="#microbenchmark-many-ties" id="toc-microbenchmark-many-ties"><span class="toc-section-number">6.0.2</span> Microbenchmark: many ties</a></li>
</ul></li>
<li><a href="#reproducibility" id="toc-reproducibility"><span class="toc-section-number">7</span> Reproducibility</a></li>
<li><a href="#references" id="toc-references"><span class="toc-section-number">8</span> References</a></li>
<li><a href="#how-to-cite-this-post" id="toc-how-to-cite-this-post"><span class="toc-section-number">9</span> How to cite this post</a></li>
</ul>
</div>

<div id="overview" class="section level1" number="1">
<h1><span class="header-section-number">1</span> Overview</h1>
<p>This post demonstrates how to move from a prototype in R to a compiled implementation with <strong>Rcpp</strong>, using <strong>Kendall‚Äôs rank correlation</strong> as a worked example. We implement a fast <strong>tau-a</strong> and <strong>tau-b</strong> estimator in <code>C++</code> (merge-sort inversion count), validate it against <code>stats::cor(..., method = "kendall")</code> on tie-free and non-tie-free data, and microbenchmark all approaches.</p>
</div>
<div id="setup" class="section level1" number="2">
<h1><span class="header-section-number">2</span> Setup</h1>
<pre class="r"><code>knitr::opts_chunk$set(cache = TRUE, autodep = TRUE)

library(Rcpp)
library(microbenchmark)
library(dplyr)
library(ggplot2)
library(knitr)
set.seed(1)</code></pre>
</div>
<div id="kendalls-tau-definitions" class="section level1" number="3">
<h1><span class="header-section-number">3</span> Kendall‚Äôs tau definitions</h1>
<p>Let <span class="math inline">\(\{(x_i,y_i)\}_{i=1}^n\)</span> be paired observations, and consider all unordered index pairs <span class="math inline">\((i,j)\)</span> with <span class="math inline">\(i&lt;j\)</span>. For each pair define</p>
<p><span class="math display">\[
  s_{ij} \,=\, \operatorname{sgn}(x_i-x_j)\,\operatorname{sgn}(y_i-y_j),
\]</span></p>
<p>with the convention <span class="math inline">\(\operatorname{sgn}(0)=0\)</span>. Thus, <span class="math inline">\(s_{ij}=+1\)</span> for concordant, <span class="math inline">\(-1\)</span> for discordant, and <span class="math inline">\(0\)</span> if the pair is tied in <span class="math inline">\(x\)</span> or in <span class="math inline">\(y\)</span> (or both).</p>
<p>Classify pairs:</p>
<ul>
<li><strong>Concordant</strong> if <span class="math inline">\((x_i-x_j)(y_i-y_j)&gt;0\)</span>.</li>
<li><strong>Discordant</strong> if <span class="math inline">\((x_i-x_j)(y_i-y_j)&lt;0\)</span>.</li>
<li><strong>Tie in</strong> <span class="math inline">\(x\)</span> if <span class="math inline">\(x_i=x_j\)</span> (regardless of <span class="math inline">\(y\)</span>).</li>
<li><strong>Tie in</strong> <span class="math inline">\(y\)</span> if <span class="math inline">\(y_i=y_j\)</span> (regardless of <span class="math inline">\(x\)</span>).</li>
</ul>
<p>Define the counts</p>
<p><span class="math display">\[
  C = \sum_{1\le i&lt;j\le n} \mathbf{1}\!\big((x_i-x_j)(y_i-y_j)&gt;0\big),\quad
  D = \sum_{1\le i&lt;j\le n} \mathbf{1}\!\big((x_i-x_j)(y_i-y_j)&lt;0\big),
\]</span></p>
<p>and let <span class="math inline">\(n_0=\binom{n}{2}\)</span> be the total number of pairs.</p>
<p>If the <span class="math inline">\(x\)</span>-values contain tie groups of sizes <span class="math inline">\(\{t_{x,g}\}\)</span> and the <span class="math inline">\(y\)</span>-values tie groups <span class="math inline">\(\{t_{y,h}\}\)</span>, the numbers of tied pairs (counting all ties, including pairs tied on both variables) are</p>
<p><span class="math display">\[
  T_x = \sum_g \binom{t_{x,g}}{2}, \qquad
  T_y = \sum_h \binom{t_{y,h}}{2}.
\]</span></p>
<p>Let <span class="math inline">\(T_{xy}\)</span> be the number of pairs tied <strong>on both</strong> variables. Then the calculating identities</p>
<p><span class="math display">\[
  n_0 = C + D + T_x + T_y - T_{xy}, \qquad \sum_{i&lt;j} s_{ij} = C - D
\]</span></p>
<p>hold.</p>
<div id="kendalls-tau_a-no-tie-correction" class="section level2" number="3.1">
<h2><span class="header-section-number">3.1</span> Kendall‚Äôs <span class="math inline">\(\tau_a\)</span> (no tie correction)</h2>
<p><span class="math display">\[
  \tau_a \,=\, \frac{C - D}{n_0} \,=\, \frac{1}{n_0}\sum_{i&lt;j} s_{ij}.
\]</span></p>
<p>This coefficient lies in <span class="math inline">\([-1,1]\)</span>. It is appropriate when ties are absent or negligible; ties contribute <span class="math inline">\(s_{ij}=0\)</span> and therefore shrink <span class="math inline">\(|\tau_a|\)</span> toward 0.</p>
</div>
<div id="kendalls-tau_b-tie-adjusted" class="section level2" number="3.2">
<h2><span class="header-section-number">3.2</span> Kendall‚Äôs <span class="math inline">\(\tau_b\)</span> (tie-adjusted)</h2>
<p><span class="math display">\[
  \tau_b \,=\, \frac{C - D}{\sqrt{\,(n_0 - T_x)\,(n_0 - T_y)\,}}.
\]</span></p>
<p>This rescales by the numbers of <em>comparable</em> pairs in each margin and preserves the <span class="math inline">\([-1,1]\)</span> range. When there are no ties (<span class="math inline">\(T_x=T_y=0\)</span>), we have <span class="math inline">\(\tau_b=\tau_a\)</span>.</p>
<blockquote>
<p><strong>Convention on double ties.</strong> Pairs tied on both variables are included in <strong>both</strong> <span class="math inline">\(T_x\)</span> and <span class="math inline">\(T_y\)</span>, matching common software implementations of <span class="math inline">\(\tau_b\)</span>. The separate term <span class="math inline">\(T_{xy}\)</span> is used only in the calculating identity above.</p>
</blockquote>
</div>
<div id="remarks-and-edge-cases" class="section level2" number="3.3">
<h2><span class="header-section-number">3.3</span> Remarks and edge cases</h2>
<p>It is important to keep in mind the following properties:</p>
<ul>
<li><strong>Degenerate margins.</strong> If all <span class="math inline">\(x\)</span> values are equal (so <span class="math inline">\(T_x=n_0\)</span>) or all <span class="math inline">\(y\)</span> values are equal (<span class="math inline">\(T_y=n_0\)</span>), the denominator of <span class="math inline">\(\tau_b\)</span> is zero and <span class="math inline">\(\tau_b\)</span> is undefined (software often returns <code>NaN</code>). In these cases, <span class="math inline">\(\tau_a=0\)</span>.</li>
<li><strong>Invariance.</strong> Both <span class="math inline">\(\tau_a\)</span> and <span class="math inline">\(\tau_b\)</span> are invariant to strictly monotone transformations of either variable.</li>
<li><strong>No ties.</strong> If there are no ties, then <span class="math inline">\(C+D=n_0\)</span> and both measures coincide: <span class="math inline">\(\tau=\frac{C-D}{n_0}\)</span>.</li>
</ul>
</div>
</div>
<div id="implementation-in-r-rcpp" class="section level1" number="4">
<h1><span class="header-section-number">4</span> Implementation in R (Rcpp)</h1>
<p>With the definitions in place, we can move from notation to a compact implementation. To enumerate all <span class="math inline">\(n_0=\binom{n}{2}\)</span> pairs efficiently, we‚Äôll use a small <code>C++</code> routine via <strong>Rcpp</strong>. The function below computes Kendall‚Äôs <span class="math inline">\(\tau_a\)</span> by tallying concordant and discordant pairs and returning <span class="math inline">\((C-D)/n_0\)</span>. When ties are common, <span class="math inline">\(\tau_b\)</span> is usually preferable; we present both approaches, but the reason to have <span class="math inline">\(\tau_a\)</span> here because it is simple and fast, and it coincides with <span class="math inline">\(\tau_b\)</span> when there are no ties.</p>
<div id="rcpp-inline-implementation-tau_a" class="section level2" number="4.1">
<h2><span class="header-section-number">4.1</span> Rcpp inline implementation (<span class="math inline">\(\tau_a\)</span>)</h2>
<p>The C++ function below is intended to be compiled inline from <code>R</code> and called as a regular <code>R</code> function. (A short note on validation follows after the code.)</p>
<pre class="r"><code>Rcpp::cppFunction(code = &#39;
#include &lt;Rcpp.h&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;
#include &lt;cmath&gt;
using namespace Rcpp;

// Merge step that counts inversions while sorting.
long long merge_count(IntegerVector&amp; arr, IntegerVector&amp; temp,
                      int left, int mid, int right) {
  int i = left, j = mid, k = left;
  long long inv_count = 0;

  while (i &lt; mid &amp;&amp; j &lt;= right) {
    if (arr[i] &lt;= arr[j]) {
      temp[k++] = arr[i++];
    } else {
      temp[k++] = arr[j++];
      inv_count += (mid - i); // elements i..mid-1 are &gt; arr[j-1]
    }
  }
  while (i &lt; mid)    temp[k++] = arr[i++];
  while (j &lt;= right) temp[k++] = arr[j++];

  for (int idx = left; idx &lt;= right; ++idx) arr[idx] = temp[idx];
  return inv_count;
}

// Recursive sort that returns inversion count.
long long sort_count(IntegerVector&amp; arr, IntegerVector&amp; temp, int left, int right) {
  if (right - left &lt; 1) return 0LL;
  int mid = left + (right - left) / 2;
  long long inv = sort_count(arr, temp, left, mid);
  inv += sort_count(arr, temp, mid + 1, right);
  inv += merge_count(arr, temp, left, mid + 1, right);
  return inv;
}

// [[Rcpp::export]]
double kendall_tau_a_cpp(NumericVector x, NumericVector y) {
  int n = x.size();
  if (n &lt; 2) return NA_REAL;

  // Indices that sort x.
  IntegerVector idx(n);
  std::iota(idx.begin(), idx.end(), 0);
  std::sort(idx.begin(), idx.end(),
            [&amp;x](int i, int j){ return x[i] &lt; x[j]; });

  // y reordered by sorted x; discretise for stable comparison.
  IntegerVector y_ord(n);
  for (int i = 0; i &lt; n; ++i) {
    y_ord[i] = (int) std::floor(y[idx[i]] * 1e8);
  }

  // Count discordances as inversions in y_ord.
  IntegerVector temp(n);
  long long discord = sort_count(y_ord, temp, 0, n - 1);

  // tau-a.
  double n0 = double(n) * double(n - 1) / 2.0;
  return (n0 - 2.0 * discord) / n0;
}
&#39;, rebuild = TRUE)</code></pre>
</div>
<div id="rcpp-inline-implementation-tau-b" class="section level2" number="4.2">
<h2><span class="header-section-number">4.2</span> Rcpp inline implementation (tau-b)</h2>
<p>This <code>C++</code> routine computes Kendall‚Äôs <strong>tau-b</strong> (tie-adjusted). It first orders observations by <span class="math inline">\(x\)</span> (breaking ties by <span class="math inline">\(y\)</span>), then uses a Fenwick tree to accumulate <span class="math inline">\(S=C-D\)</span> by comparing each group (equal <span class="math inline">\(x\)</span>) only to previously seen values (so pairs tied on either variable do not enter the numerator). The tie counts <span class="math inline">\(T_x\)</span> and <span class="math inline">\(T_y\)</span> are computed explicitly and used in the denominator <span class="math inline">\(\sqrt{(n_0-T_x)(n_0-T_y)}\)</span>, yielding a coefficient in <span class="math inline">\([-1,1]\)</span> that matches <code>stats::cor(..., method = "kendall")</code> on tied data. Time complexity is <span class="math inline">\(O(n\log n)\)</span>. Floating inputs are discretised (scale factor <span class="math inline">\(10^8\)</span>) to stabilise equality checks; for heavily discretised data we may prefer pre-ranking to integers.</p>
<pre class="r"><code>Rcpp::cppFunction(code = &quot;
#include &lt;Rcpp.h&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
using namespace Rcpp;

struct Fenwick {
  std::vector&lt;long long&gt; t;
  int n;
  Fenwick(int n) : t(n + 1, 0), n(n) {}
  void add(int i, long long v){
    for(; i &lt;= n; i += i &amp; -i) t[i] += v;
  }
  long long sum(int i) const {
    long long s = 0;
    for(; i &gt; 0; i -= i &amp; -i) s += t[i];
    return s;
  }
};  // 

// [[Rcpp::export]]
double kendall_tau_b_cpp(NumericVector x, NumericVector y) {
  const int n = x.size();
  if (n &lt; 2) return NA_REAL;

  // Discretise to integers for stable tie detetion with floating inputs.
  std::vector&lt;long long&gt; xi(n), yi(n);
  for (int i = 0; i &lt; n; ++i) {
    xi[i] = (long long) std::floor(x[i] * 1e8);
    yi[i] = (long long) std::floor(y[i] * 1e8);
  }

  // Order by x then y
  std::vector&lt;int&gt; ord(n);
  std::iota(ord.begin(), ord.end(), 0);
  std::sort(ord.begin(), ord.end(), [&amp;](int a, int b){
    if (xi[a] != xi[b]) return xi[a] &lt; xi[b];
    return yi[a] &lt; yi[b];
  });

  // Create T_x (pairs tied on x)
  long long T_x = 0;
  for (int i = 0; i &lt; n; ){
    int j = i + 1;
    while (j &lt; n &amp;&amp; xi[ord[j]] == xi[ord[i]]) ++j;
    long long g = j - i;
    T_x += g * (g - 1) / 2;
    i = j;
  }

  // Create T_y (pairs tied on y)
  std::vector&lt;long long&gt; y_sorted = yi;
  std::sort(y_sorted.begin(), y_sorted.end());
  long long T_y = 0;
  for (int i = 0; i &lt; n; ){
    int j = i + 1;
    while (j &lt; n &amp;&amp; y_sorted[j] == y_sorted[i]) ++j;
    long long g = j - i;
    T_y += g * (g - 1) / 2;
    i = j;
  }

  // Coordinate-compress y
  std::vector&lt;long long&gt; y_unique = y_sorted;
  y_unique.erase(std::unique(y_unique.begin(), y_unique.end()), y_unique.end());
  auto rank_of = [&amp;](long long v){
    return (int)(std::lower_bound(y_unique.begin(), y_unique.end(), v) - 
                                  y_unique.begin()) + 1; // 1-based
  };

  // S = C - D via BIT; group by equal x so x-ties contribute zero
  Fenwick bit((int) y_unique.size());
  long long processed = 0;
  long long S = 0;

  for (int i = 0; i &lt; n; ){
    int j = i + 1;
    while (j &lt; n &amp;&amp; xi[ord[j]] == xi[ord[i]]) ++j;

    // Compare current x-group against all prior items (strict &lt; and &gt;)
    for (int k = i; k &lt; j; ++k) {
      int idx = ord[k];
      int r = rank_of(yi[idx]);
      // y_prev &lt; y
      long long less    = bit.sum(r - 1);   
      // y_prev &lt;= y
      long long leq     = bit.sum(r);       
      // y_prev &gt; y
      long long greater = processed - leq;  
      // +1 for concordant, -1 for discordant
      S += (less - greater);
    }

    // Insert current group into the tree
    for (int k = i; k &lt; j; ++k) {
      int r = rank_of(yi[ord[k]]);
      bit.add(r, 1);
    }
    processed += (j - i);
    i = j;
  }

  const double n0      = (double) n * (double) (n - 1) / 2.0;
  const double denom_x = n0 - (double) T_x;
  const double denom_y = n0 - (double) T_y;
  if (denom_x &lt;= 0.0 || denom_y &lt;= 0.0) return NA_REAL;

  const double denom = std::sqrt(denom_x * denom_y);
  return (double) S / denom;
}
&quot;)</code></pre>
</div>
</div>
<div id="sanity-checks-considering-tie-free-vs-tie-heavy-data" class="section level1" number="5">
<h1><span class="header-section-number">5</span> Sanity checks considering tie-free vs tie-heavy data</h1>
<p>In practice, Kendall‚Äôs rank correlation behaves differently depending on the prevalence of ties. The <strong>tau-a</strong> normalisation uses the total number of unordered pairs <span class="math inline">\(n_0=\binom{n}{2}\)</span> and does not adjust for ties, whereas <strong>tau-b</strong> rescales by <span class="math inline">\(\sqrt{(n_0-T_x)(n_0-T_y)}\)</span> to remove the influence of ties in <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>. Base R‚Äôs <code>cor(..., method = "kendall")</code> implements a tie-aware estimator (tau-b‚Äìtype normalisation). The aim of this section is therefore twofold (i) to show agreement amongst implementations when ties are essentially absent, and (ii) to illustrate the expected divergence of tau-a from tie-aware estimators when ties are pervasive‚Äîtypical of discretised scores or coarse measurements in breeding datasets.</p>
<div id="tie-free-continuous-data" class="section level2" number="5.1">
<h2><span class="header-section-number">5.1</span> Tie-free (continuous) data</h2>
<p>With continuous, independent draws (here, Gaussian), ties are virtually absent. Under this regime, tau-a and tau-b coincide up to Monte Carlo error, and both agree with base <code>R</code>. Any residual differences are due to finite-sample variability and numerical details (e.g., discretisation safeguards in the <code>C++</code> code). This scenario serves as a basic correctness check before considering tie handling.</p>
<pre class="r"><code>set.seed(1)
n_noties &lt;- 5000L
x0 &lt;- rnorm(n_noties)
y0 &lt;- rnorm(n_noties)

tau_a_noties  &lt;- kendall_tau_a_cpp(x0, y0)
tau_b_noties  &lt;- kendall_tau_b_cpp(x0, y0)
tau_r_noties  &lt;- suppressWarnings(stats::cor(x0, y0, method = &quot;kendall&quot;))

dplyr::tibble(
  scenario   = &quot;no ties&quot;,
  tau_a_cpp  = tau_a_noties,
  tau_b_cpp  = tau_b_noties,
  tau_baseR  = tau_r_noties,
  abs_diff_a_vs_base = abs(tau_a_noties - tau_r_noties),
  abs_diff_b_vs_base = abs(tau_b_noties - tau_r_noties)
) |&gt;
  knitr::kable(digits = 6, caption = &quot;Tie-free data: Kendall estimates (tau-a, tau-b, base R)&quot;)</code></pre>
<table style="width:100%;">
<caption>(#tab:sanity_noties)Tie-free data: Kendall estimates (tau-a, tau-b, base R)</caption>
<colgroup>
<col width="11%" />
<col width="12%" />
<col width="12%" />
<col width="12%" />
<col width="24%" />
<col width="24%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">scenario</th>
<th align="right">tau_a_cpp</th>
<th align="right">tau_b_cpp</th>
<th align="right">tau_baseR</th>
<th align="right">abs_diff_a_vs_base</th>
<th align="right">abs_diff_b_vs_base</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">no ties</td>
<td align="right">-9.1e-05</td>
<td align="right">-9.1e-05</td>
<td align="right">-9.1e-05</td>
<td align="right">0</td>
<td align="right">0</td>
</tr>
</tbody>
</table>
</div>
<div id="tie-heavy-data-we-have-tau_b-approx-base-r-tau_a-differs" class="section level2" number="5.2">
<h2><span class="header-section-number">5.2</span> Tie-heavy data we have <span class="math inline">\(\tau_b \approx\)</span> base R, <span class="math inline">\(\tau_a\)</span> differs</h2>
<p>When many observations share identical values (here enforced by sampling small integers), a substantial fraction of pairs are tied on <span class="math inline">\(x\)</span>, on <span class="math inline">\(y\)</span>, or on both. Tau-b explicitly discounts such tied pairs in the denominator and therefore remains on the same scale as base <code>R</code>. In contrast, tau-a retains <span class="math inline">\(n_0\)</span> in the denominator while excluding tied pairs from the numerator, pulling estimates towards zero as ties increase. In applied settings (e.g., ordinal disease scores, rounded phenotypes, or coarsened environmental indices), a tie-adjusted coefficient such as tau-b is generally preferable.</p>
<pre class="r"><code>set.seed(2)
n_ties &lt;- 5000L
# Create many ties by sampling integers (stronger ties than rounding)
x1 &lt;- sample.int(40L, n_ties, replace = TRUE)
y1 &lt;- sample.int(50L, n_ties, replace = TRUE)

tau_a_ties  &lt;- kendall_tau_a_cpp(x1, y1)
tau_b_ties  &lt;- kendall_tau_b_cpp(x1, y1)
tau_r_ties  &lt;- suppressWarnings(stats::cor(x1, y1, method = &quot;kendall&quot;))

dplyr::tibble(
  scenario   = &quot;many ties&quot;,
  tau_a_cpp  = tau_a_ties,
  tau_b_cpp  = tau_b_ties,
  tau_baseR  = tau_r_ties,
  abs_diff_a_vs_base = abs(tau_a_ties - tau_r_ties),
  abs_diff_b_vs_base = abs(tau_b_ties - tau_r_ties)
) |&gt;
  knitr::kable(digits = 6, 
               caption = &quot;Tie-heavy data: Kendall estimates (tau-a, tau-b, base R)&quot;)</code></pre>
<table>
<caption>(#tab:sanity_ties)Tie-heavy data: Kendall estimates (tau-a, tau-b, base R)</caption>
<colgroup>
<col width="12%" />
<col width="12%" />
<col width="12%" />
<col width="12%" />
<col width="24%" />
<col width="24%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">scenario</th>
<th align="right">tau_a_cpp</th>
<th align="right">tau_b_cpp</th>
<th align="right">tau_baseR</th>
<th align="right">abs_diff_a_vs_base</th>
<th align="right">abs_diff_b_vs_base</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">many ties</td>
<td align="right">0.349282</td>
<td align="right">-0.015499</td>
<td align="right">-0.015499</td>
<td align="right">0.364781</td>
<td align="right">0</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="benchmark-design-microbenchmarks-no-ties-vs-many-ties" class="section level1" number="6">
<h1><span class="header-section-number">6</span> Benchmark design &amp; microbenchmarks (no ties vs many ties)</h1>
<p>We benchmark three implementations on <span class="math inline">\(n=10{,}000\)</span> pairs. A <code>C++</code> <strong>tau-a</strong> (merge-sort inversion count), a <code>C++</code> <strong>tau-b</strong> (Fenwick tree with explicit tie counts), and base <code>R</code>‚Äôs Kendall (tie-aware, <span class="math inline">\(O(n\log n)\)</span>). Each method is run 50 times after a warm-up to amortise compilation and jit effects. Results are summarised by the median and IQR of wall-clock times. Absolute timings will depend on hardware and compilation flags. Note that the principal comparison is relative performance under differing tie structures.</p>
<pre class="r"><code>set.seed(3)
n_bench &lt;- 10000L

# No-ties benchmark data
xb &lt;- rnorm(n_bench)
yb &lt;- rnorm(n_bench)

# Many-ties benchmark data
xbt &lt;- sample.int(200L, n_bench, replace = TRUE)
ybt &lt;- sample.int(220L, n_bench, replace = TRUE)

# Warm-up (compile and JIT call paths)
invisible(kendall_tau_a_cpp(xb,  yb))
invisible(kendall_tau_b_cpp(xbt, ybt))
invisible(stats::cor(xb,  yb,  method = &quot;kendall&quot;))
invisible(stats::cor(xbt, ybt, method = &quot;kendall&quot;))</code></pre>
<div id="microbenchmark-tie-free-data" class="section level3" number="6.0.1">
<h3><span class="header-section-number">6.0.1</span> Microbenchmark: tie-free data</h3>
<p>On essentially tie-free inputs, all algorithms are <span class="math inline">\(O(n\log n)\)</span> but differ in constants. The tau-a routine often has a slight advantage because it avoids tie searching. Agreement in estimates alongside stable timing indicates the implementations are behaving as expected in the, let‚Äôs say, ``easy‚Äù regime.</p>
<pre class="r"><code>mb_noties &lt;- microbenchmark::microbenchmark(
  cpp_tau_a  = kendall_tau_a_cpp(xb, yb),
  cpp_tau_b  = kendall_tau_b_cpp(xb, yb),
  base_kendall = stats::cor(xb, yb, method = &quot;kendall&quot;),
  times = 50L
)

mb_noties_sum &lt;- as.data.frame(mb_noties) |&gt;
  dplyr::group_by(expr) |&gt;
  dplyr::summarise(
    median_ms = median(time) / 1e6,
    iqr_ms    = IQR(time) / 1e6,
    min_ms    = min(time) / 1e6,
    max_ms    = max(time) / 1e6,
    .groups = &quot;drop&quot;
  ) |&gt;
  dplyr::arrange(median_ms)

knitr::kable(mb_noties_sum, digits = 2,
             caption = &quot;Microbenchmark (no ties, n = 10,000): tau-a (C++), tau-b (C++), base R&quot;)</code></pre>
<table>
<caption>(#tab:bench_noties)Microbenchmark (no ties, n = 10,000): tau-a (C++), tau-b (C++), base R</caption>
<thead>
<tr class="header">
<th align="left">expr</th>
<th align="right">median_ms</th>
<th align="right">iqr_ms</th>
<th align="right">min_ms</th>
<th align="right">max_ms</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">cpp_tau_a</td>
<td align="right">2.54</td>
<td align="right">1.57</td>
<td align="right">1.96</td>
<td align="right">6.68</td>
</tr>
<tr class="even">
<td align="left">cpp_tau_b</td>
<td align="right">4.30</td>
<td align="right">2.39</td>
<td align="right">3.49</td>
<td align="right">7.76</td>
</tr>
<tr class="odd">
<td align="left">base_kendall</td>
<td align="right">1843.07</td>
<td align="right">357.48</td>
<td align="right">1522.52</td>
<td align="right">2327.39</td>
</tr>
</tbody>
</table>
<pre class="r"><code>ggplot2::ggplot(as.data.frame(mb_noties),
                ggplot2::aes(x = expr, y = time/1e6)) +
  ggplot2::geom_boxplot(outlier.alpha = 0.15) +
  ggplot2::labs(x = NULL, y = &quot;Time (ms)&quot;,
       title = &quot;No ties: kendall_tau_a_cpp / kendall_tau_b_cpp / base R&quot;) +
  ggplot2::theme_minimal(base_size = 12)</code></pre>
<p><img src="{{< blogdown/postref >}}index_files/figure-html/plot_bench_noties-1.png" width="672" /></p>
</div>
<div id="microbenchmark-many-ties" class="section level3" number="6.0.2">
<h3><span class="header-section-number">6.0.2</span> Microbenchmark: many ties</h3>
<p>With many ties, tie-aware methods incur modest overhead for counting and handling groups, yet remain <span class="math inline">\(O(n\log n)\)</span>. The tau-a routine may be fastest but is estimating a different quantity in this regime; its computational advantage should not be traded off against interpretability when ties matter. In most breeding or agricultural datasets with discrete or rounded measures, the tau-b (or base <code>R</code>) path is the appropriate comparator.</p>
<pre class="r"><code>mb_ties &lt;- microbenchmark::microbenchmark(
  cpp_tau_a    = kendall_tau_a_cpp(xbt, ybt),
  cpp_tau_b    = kendall_tau_b_cpp(xbt, ybt),
  base_kendall = stats::cor(xbt, ybt, method = &quot;kendall&quot;),
  times = 50L
)

mb_ties_sum &lt;- as.data.frame(mb_ties) |&gt;
  dplyr::group_by(expr) |&gt;
  dplyr::summarise(
    median_ms = median(time) / 1e6,
    iqr_ms    = IQR(time) / 1e6,
    min_ms    = min(time) / 1e6,
    max_ms    = max(time) / 1e6,
    .groups = &quot;drop&quot;
  ) |&gt;
  dplyr::arrange(median_ms)

knitr::kable(mb_ties_sum, digits = 2,
             caption = &quot;Microbenchmark (many ties, n = 10,000): tau-a (C++), tau-b (C++), base R&quot;)</code></pre>
<table>
<caption>(#tab:bench_ties)Microbenchmark (many ties, n = 10,000): tau-a (C++), tau-b (C++), base R</caption>
<thead>
<tr class="header">
<th align="left">expr</th>
<th align="right">median_ms</th>
<th align="right">iqr_ms</th>
<th align="right">min_ms</th>
<th align="right">max_ms</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">cpp_tau_a</td>
<td align="right">1.38</td>
<td align="right">0.89</td>
<td align="right">1.07</td>
<td align="right">4.06</td>
</tr>
<tr class="even">
<td align="left">cpp_tau_b</td>
<td align="right">2.75</td>
<td align="right">1.86</td>
<td align="right">2.17</td>
<td align="right">6.15</td>
</tr>
<tr class="odd">
<td align="left">base_kendall</td>
<td align="right">1690.84</td>
<td align="right">144.63</td>
<td align="right">1543.99</td>
<td align="right">2041.61</td>
</tr>
</tbody>
</table>
<pre class="r"><code>ggplot2::ggplot(as.data.frame(mb_ties),
                ggplot2::aes(x = expr, y = time/1e6)) +
  ggplot2::geom_boxplot(outlier.alpha = 0.15) +
  ggplot2::labs(x = NULL, y = &quot;Time (ms)&quot;,
       title = &quot;Many ties: kendall_tau_a_cpp / kendall_tau_b_cpp / base R&quot;) +
  ggplot2::theme_minimal(base_size = 12)</code></pre>
<p><img src="{{< blogdown/postref >}}index_files/figure-html/plot_bench_ties-1.png" width="672" />
As you probably noted until here, in both scenarios <span class="math inline">\((n=10{,}000)\)</span>, the <code>C++</code> implementations are orders of magnitude faster than base R. Specifically in the last scenario:</p>
<ul>
<li><strong>cpp tau-a</strong> has a median <span class="math inline">\(1.21\)</span> ms being <span class="math inline">\(\approx 1,269 \times\)</span> faster than base <code>R</code> (<span class="math inline">\(1,535.89\)</span> ms).</li>
<li><strong>cpp tau-b:</strong> has median <span class="math inline">\(2.38\)</span> ms being <span class="math inline">\(\approx 645 \times\)</span> faster than base <code>R</code>.</li>
<li><strong>tau-b vs tau-a:</strong> tau-b is <span class="math inline">\(\approx 2.0 \times\)</span> slower than tau-a, reflecting the extra work needed for tie handling.</li>
</ul>
<p>The IQRs (0.18 ms for tau-a; 0.46 ms for tau-b; 214.89 ms for base <code>R</code>) indicate the <code>C++</code> timings are not only faster but also far more stable. Practically, this means we can use the tie-adjusted <strong>tau-b C++</strong> routine without sacrificing performance; the <span class="math inline">\(\approx 2.0 \times\)</span> overhead relative to tau-a is negligible in absolute terms, while the gap to base <code>R</code> remains several orders of magnitude.</p>
</div>
</div>
<div id="reproducibility" class="section level1" number="7">
<h1><span class="header-section-number">7</span> Reproducibility</h1>
<pre class="r"><code>sessionInfo()</code></pre>
<pre><code>## R version 4.4.3 (2025-02-28 ucrt)
## Platform: x86_64-w64-mingw32/x64
## Running under: Windows 11 x64 (build 22631)
## 
## Matrix products: default
## 
## 
## locale:
## [1] LC_COLLATE=English_United Kingdom.utf8 
## [2] LC_CTYPE=English_United Kingdom.utf8   
## [3] LC_MONETARY=English_United Kingdom.utf8
## [4] LC_NUMERIC=C                           
## [5] LC_TIME=English_United Kingdom.utf8    
## 
## time zone: Europe/London
## tzcode source: internal
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
## [1] knitr_1.50            ggplot2_3.5.2         dplyr_1.1.4          
## [4] microbenchmark_1.4.10 Rcpp_1.1.0           
## 
## loaded via a namespace (and not attached):
##  [1] gtable_0.3.6       jsonlite_1.8.8     compiler_4.4.3     tidyselect_1.2.1  
##  [5] dichromat_2.0-0.1  jquerylib_0.1.4    scales_1.4.0       yaml_2.3.10       
##  [9] fastmap_1.2.0      R6_2.6.1           labeling_0.4.3     generics_0.1.4    
## [13] tibble_3.2.1       bookdown_0.40      bslib_0.7.0        pillar_1.11.0     
## [17] RColorBrewer_1.1-3 rlang_1.1.6        cachem_1.1.0       xfun_0.52         
## [21] sass_0.4.9         cli_3.6.2          withr_3.0.2        magrittr_2.0.3    
## [25] digest_0.6.35      grid_4.4.3         rstudioapi_0.17.1  lifecycle_1.0.4   
## [29] vctrs_0.6.5        evaluate_1.0.4     glue_1.7.0         farver_2.1.2      
## [33] blogdown_1.21      codetools_0.2-20   rmarkdown_2.29     tools_4.4.3       
## [37] pkgconfig_2.0.3    htmltools_0.5.8.1</code></pre>
<p><strong>Did you find this page helpful? Consider sharing it üôå</strong></p>
</div>
<div id="references" class="section level1" number="8">
<h1><span class="header-section-number">8</span> References</h1>
<p>Kendall, M. G., &amp; Gibbons, J. D. (1990). (5th ed.). Oxford University Press.</p>
<p>Agresti, A. (2010). (2nd ed.). Wiley. <a href="https://doi.org/10.1002/9780470594001" class="uri">https://doi.org/10.1002/9780470594001</a></p>
</div>
<div id="how-to-cite-this-post" class="section level1" number="9">
<h1><span class="header-section-number">9</span> How to cite this post</h1>
<p>Oliveira, T. de paula. (2025, August 9). Benchmarking Kendall‚Äôs tau in R and Rcpp.
<a href="https://prof-thiagooliveira.netlify.app/post/benchmarking-kendalls-tau-r-rcpp/" class="uri">https://prof-thiagooliveira.netlify.app/post/benchmarking-kendalls-tau-r-rcpp/</a></p>
<style>
/* ====== Post-only layout + typography polish (Hugo Blox / Tailwind) ====== */
/* Place this at the very end of the post so it wins the cascade. */

/* 0) Widen the page shell Hugo Blox uses around articles */
.page-body > .mx-auto,
.page-body .max-w-screen-xl{
  max-width: 100vw !important;
  width: 100% !important;
  padding-left: 0 !important;
  padding-right: 0 !important;
}

/* 1) Remove the Tailwind max-w cap on the <main> inside <article> */
.page-body article > main{
  max-width: none !important;  /* beats .max-w-6xl */
  width: 100% !important;
}

/* 2) Control the actual reading width (fluid per breakpoint) */
.page-body article .prose{
  /* Base: a touch larger with comfy line height */
  font-size: clamp(1rem, 0.96rem + 0.25vw, 1.12rem);
  line-height: 1.75;
  text-align: left;
  margin-inline: auto;

  /* Reading width: scale up on big screens, but keep lines readable */
  max-width: 86ch !important; /* default desktop */
}
@media (min-width: 1024px){  /* lg */
  .page-body article .prose{ max-width: 96ch !important; }
}
@media (min-width: 1280px){  /* xl */
  .page-body article .prose{ max-width: 102ch !important; }
}
@media (min-width: 1536px){  /* 2xl / very wide */
  .page-body article .prose{ max-width: 108ch !important; }
}

/* 3) Phones/tablets: full width with side padding */
@media (max-width: 768px){
  .page-body article .prose{
    max-width: 100% !important;
    padding-inline: 1rem;
  }
}

/* 4) Give the article more room by slimming sidebars on wide screens */
@media (min-width: 1280px){
  .hb-sidebar-container, .hb-toc { width: 12rem !important; } /* was 16rem */
}
@media (max-width: 1279.98px){
  .hb-sidebar-container{ display:none !important; } /* hide sidebar under xl */
}

/* --------- Clean, professional type polish (scoped to post content) -------- */
.page-body article .prose p{
  margin: 0 0 1.15em;
  text-wrap: pretty;
  hyphens: auto;
}

.page-body article .prose h1{
  font-size: clamp(1.9rem, 1.6rem + 1.2vw, 2.3rem);
  margin: 1.2em 0 .5em;
  padding-bottom: .25em;
  border-bottom: 2px solid #e5e7eb;
}
.page-body article .prose h2{
  font-size: clamp(1.4rem, 1.2rem + 0.6vw, 1.7rem);
  margin: 1.35em 0 .4em;
  padding-bottom: .2em;
  border-bottom: 1px solid #e5e7eb;
}
.page-body article .prose h3{
  font-size: clamp(1.15rem, 1.05rem + 0.35vw, 1.35rem);
  margin: 1.1em 0 .3em;
}

/* Links: subtle underline-on-hover */
.page-body article .prose a{
  color: #2f6ab5;
  text-decoration: none;
  border-bottom: 1px solid rgba(47,106,181,.25);
}
.page-body article .prose a:hover{
  color: #1f4f8f;
  border-bottom-color: currentColor;
}

/* Code blocks & inline code */
.page-body article .prose pre{
  background: #f6f8fa;
  border: 1px solid #e5e7eb;
  border-radius: 8px;
  padding: 12px 14px;
  overflow: auto;
}
.page-body article .prose code{
  background: #f6f8fa;
  border: 1px solid #e5e7eb;
  border-radius: 5px;
  padding: .15em .35em;
  font-size: .95em;
}
.page-body article .prose pre code{
  background: none; border: 0; padding: 0; font-size: 0.95em;
}

/* Tables */
.page-body article .prose table{
  width: 100%;
  border-collapse: collapse;
  margin: 1.2rem 0;
  font-variant-numeric: tabular-nums;
}
.page-body article .prose th,
.page-body article .prose td{
  border: 1px solid #e5e7eb;
  padding: .6rem .75rem;
}
.page-body article .prose thead th{
  background: #2f6ab5;
  color: #fff;
  text-align: left;
}

/* Images & figures */
.page-body article .prose img{ border-radius: 6px; }

/* Optional: allow ‚Äúfull-bleed‚Äù wide elements
   Add class="wide" to a block (table/pre/img wrapper) to span the viewport. */
.page-body article .prose .wide{
  width: 100vw;
  position: relative;
  left: 50%;
  right: 50%;
  margin-left: -50vw;
  margin-right: -50vw;
  padding-inline: clamp(12px, 4vw, 36px);
}

/* Footer timestamp spacing */
.page-body article time{ margin-top: 2rem; display: block; }

/* Dark mode tweaks */
html.dark .page-body article .prose pre,
html.dark .page-body article .prose code{
  background: #111826;
  border-color: #253041;
}
html.dark .page-body article .prose thead th{ background: #5aa0ff; }
</style>
</div>
