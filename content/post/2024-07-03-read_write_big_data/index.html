---
title: Comparing data read and write performance in R
author: Thiago de Paula Oliveira
date: '2024-07-10'
slug: data-read-write-performance
categories:
  - R Programming
  - Data handling
tags:
  - Data read
  - Data write
  - Benchmarking
  - R
subtitle: 'Performance comparison of different data formats in R'
summary: 'This post explores the performance of various data formats in R for reading and writing operations, highlighting file size, speed, and memory usage.'
authors: 
- admin
lastmod: '2024-07-10T09:15:54Z'
featured: no
image:
  caption: ''
  focal_point: ''
  preview_only: no
projects: []
output:
  html_document:
    keep_md: yes
    toc: true
---



<style>
/* Blog post container */
body {
   font-family: 'Helvetica Neue', Arial, sans-serif;
   font-size: 1rem;
   line-height: 1.8;
   color: #333;
   text-align: justify;
   background-color: #fafafa;
   margin: 0;
   padding: 0 20px;
}

/* Header styling */
h1, 
h2, 
h3, 
h4, 
h5, 
h6 {
  font-weight: 600; /* Semi-bold for a professional look */
  margin-bottom: 0.75em; /* Slightly reduced bottom margin */
  color: #0d0d0d;
  line-height: 1.2;
  margin-top: 1.5em; /* Added top margin for consistency */
}

h1 {
  font-size: 1.75rem; 
  border-bottom: 2px solid #3b80d1;
  padding-bottom: 0.3em; /* Padding for visual separation */
  margin-top: 1em; 
}

h2 {
  font-size: 1.5rem; 
  color: #3b80d1;
  padding-bottom: 0.2em; /* Padding for visual separation */
}

h3 {
  font-size: 1.25rem; 
  color: #333;
}

h4 {
  font-size: 1.125rem; 
  color: #333;
}

h5 {
  font-size: 1rem; 
  color: #333;
}

h6 {
  font-size: 0.875rem; 
  color: #333;
}

/* Link styling */
a {
  color: #3b80d0;
  text-decoration: none;
  transition: color 0.3s ease;
}

a:hover {
  text-decoration: underline;
  color: #1a57a0;
}

/* Code styling */
pre, 
.code-input {
  background-color: #f5f5f5;
  border: 1px solid #ddd;
  padding: 10px;
  font-size: 0.9rem;
  border-radius: 5px;
  margin: 20px 0;
  overflow-x: auto;
}

code {
  font-size: 0.9rem;
  background-color: #f5f5f5;
  padding: 2px 4px;
  border-radius: 3px;
}

/* Table styling */
table {
  width: 100%;
  border-collapse: collapse;
  margin-bottom: 1.5em;
  text-align: left;
}

th, 
td {
  padding: 12px;
  border: 1px solid #ddd;
}

th {
  background-color: #3b80d1;
  color: white;
}

/* Div options - color box text */
.div-1 {
  color: black;
  background-color: #d6edd3;
  padding: 10px;
  border-radius: 5px;
  margin-bottom: 1.5em;
}

.div-2 {
  color: black;
  background-color: #cfbe7e;
  padding: 10px;
  border-radius: 5px;
  margin-bottom: 1.5em;
}

/* Article content */
.article-content {
  text-align: justify;
}

/* Image styling */
img {
  max-width: 100%;
  height: auto;
  border-radius: 5px;
  margin-bottom: 1.5em;
}
</style>
<div id="post-summary" class="section level1">
<h1>Post Summary</h1>
<p>Efficient data handling is crucial for daily data analysis tasks. In this post, we will compare the performance of various data formats in <code>R</code> for reading and writing operations. The formats considered include RDS, CSV (using <code>data.table</code> and <code>readr</code>), FST, Feather, Parquet, and QS. We will benchmark the speed, file sizes, and memory usage of each format across different data sizes.</p>
</div>
<div id="database-definition" class="section level1">
<h1>Database Definition</h1>
<p>In this section, we will describe each of the data formats in detail, highlighting their strengths and weaknesses. We will provide insights into the specific use cases where each format excels. The choice of format will depend on the specific needs of the data analysis tasks.</p>
<div id="rds" class="section level2">
<h2>RDS</h2>
<p>RDS is a format native to <code>R</code> that is highly efficient for saving single R objects. The <code>saveRDS()</code> and <code>readRDS()</code> functions are used to write and read <code>R</code> objects, respectively. RDS seamlessly integrates with <code>R</code>, retaining object metadata including data types and structures, which is beneficial for preserving the exact state of an <code>R</code> object. It provides fast read and write operations for moderate data sizes, making it suitable for storing intermediate results and final outputs in <code>R</code>. Additionally, it is easy to use with built-in <code>R</code> functions. However, it can result in larger file sizes compared to some compressed formats due to lack of advanced compression. Moreover, RDS has limited compatibility with other software or programming languages, limiting its use for data sharing outside of <code>R</code> environments.</p>
</div>
<div id="qs" class="section level2">
<h2>QS</h2>
<p>QS (Quick Serialization of <code>R</code> objects) is a binary format for <code>R</code> objects that emphasizes speed and compression. It uses advanced compression algorithms to achieve high performance. QS provides extremely fast read and write operations, even for large data sets, making it suitable for high-performance computing tasks. It uses advanced compression techniques to reduce file size significantly without compromising on speed. Additionally, QS preserves <code>R</code> object metadata, ensuring that data types and structures are maintained. However, QS is mainly designed for use within <code>R</code>, with limited support in other programming environments. It also requires familiarity with additional functions and parameters to fully leverage its capabilities, which might be a barrier for new users. The goal of this package is to provide a lightning-fast and complete replacement for the <code>saveRDS</code> and <code>readRDS</code> functions in <code>R</code>.</p>
</div>
<div id="csv-using-data.table-and-readr" class="section level2">
<h2>CSV (using <code>data.table</code> and <code>readr</code>)</h2>
<p>CSV (Comma-Separated Values) is a plain text format widely used for data storage and transfer. <code>R</code> offers multiple ways to handle CSV files, with <code>data.table</code> and <code>readr</code> being popular for their speed and efficiency. The universality of CSV makes it readable across different software and programming languages. Its simple, plain text format can be easily inspected and edited manually, facilitating easy debugging and quick checks. Moreover, <code>data.table</code> and <code>readr</code> provide efficient functions for reading and writing CSV files in <code>R</code>, enhancing performance over base <code>R</code> functions. However, CSV does not retain data types and structure information, requiring manual handling and potential data type issues when reading back. It is generally slower for large data sets compared to binary formats due to the need to parse text. The text format also results in larger file sizes, especially for large data sets with many rows and columns.</p>
</div>
<div id="columnar-storage-formats" class="section level2">
<h2>Columnar storage formats</h2>
<p>Columnar storage is a method of storing data tables that improves the efficiency of reading and writing operations, especially for large data sets. Instead of storing data row by row, columnar storage organizes data by columns. This allows for more efficient data compression and faster retrieval of specific columns, which is particularly beneficial for analytical queries that often access a subset of columns from a large data set.</p>
<div id="fst" class="section level3">
<h3>FST</h3>
<p>The <code>fst</code> package is a fast, binary data format for <code>R</code> data frames. It uses a highly efficient columnar storage format and supports multiple compression algorithms. FST offers extremely fast read and write operations, especially for large data sets, making it ideal for scenarios requiring frequent data access and manipulation. It efficiently compresses data, reducing file size significantly without sacrificing speed. The columnar storage format is optimized for columnar data access, enhancing speed for specific column retrieval and partial data loading. While FST is primarily designed for use within <code>R</code>, it is not limited to it. The <code>pyfst</code> library, for example, provides an interface to the <code>OpenFst</code> library, enabling similar fast storage and retrieval functionalities in Python. However, within <code>R</code>, FST can be slightly more complex to use compared to native formats due to additional options and parameters for compression and storage.</p>
</div>
<div id="feather" class="section level3">
<h3>Feather</h3>
<p>Feather is a binary columnar data format that is part of the Apache Arrow project. It provides efficient storage for data frames and supports interchangeability between different languages. Feather supports interchangeability between <code>R</code>, Python, and other languages, making it a great choice for multi-language data workflows. It offers fast read and write speeds due to columnar storage, suitable for handling large data sets efficiently. It is also easy to use with the <code>arrow</code> package in <code>R</code>, allowing straightforward data exchange and manipulation. However, file sizes are generally larger than highly compressed formats like FST or Parquet, which might be a concern for very large data sets. Additionally, Feather is continually evolving, which might affect long-term stability and require frequent updates.</p>
</div>
<div id="parquet" class="section level3">
<h3>Parquet</h3>
<p>Parquet is a columnar storage file format optimized for large-scale data processing and is part of the Apache Hadoop ecosystem. Parquet is widely supported across different programming languages and big data tools, including <code>R</code>, Python, Spark, and more, facilitating seamless data exchange. It uses highly efficient data compression and encoding schemes to reduce file sizes significantly while maintaining performance. The columnar storage format is optimized for read performance on large data sets, especially when querying specific columns, making it ideal for big data applications. However, Parquet is more complex to handle due to advanced features and options for compression, encoding, and storage management.</p>
</div>
</div>
</div>
<div id="data-simulation" class="section level1">
<h1>Data Simulation</h1>
<p>To evaluate the performance of various data formats, we generated sample datasets of varying sizes using a custom data generation function. This function creates data frames with three columns: an <code>ID</code> column with sequential integers, a <code>Value</code> column with random normal values, and a <code>Group</code> column with randomly selected letters. The sizes of the datasets range from 100 to 10 million rows, allowing us to assess the performance across different scales. The random seed is set to <span class="math inline">\(123\)</span> to ensure reproducibility of the generated data.</p>
<pre><code># Function to generate sample datasets
generate_sample_data &lt;- function(n) {
  set.seed(123)
  data.frame(
    ID = 1:n,
    Value = rnorm(n),
    Group = sample(letters, n, replace = TRUE)
  )
}

# Define dataset sizes
dataset_sizes &lt;- c(1e2, 1e3, 1e4, 1e5, 1e6, 1e7)</code></pre>
<div id="benchmarking-read-and-write-performance" class="section level2">
<h2>Benchmarking read and write performance</h2>
<p>The benchmarking process involves measuring the time taken to read from and write to different data formats. We used the <code>microbenchmark</code> package in <code>R</code> to perform these measurements, ensuring that each operation is repeated 30 times to obtain reliable statistics.</p>
For writing operations, we utilized the following functions:
<ul>
<li>
<code>saveRDS()</code> for RDS files
</li>
<li>
<code>fwrite()</code> from the <code>data.table</code> package for CSV files
</li>
<li>
<code>write_fst()</code> from the <code>fst</code> package for FST files
</li>
<li>
<code>write_feather()</code> from the <code>arrow</code> package for Feather files
</li>
<li>
<code>qsave()</code> from the <code>qs</code> package for QS files
</li>
<li>
<code>write_csv()</code> from the <code>readr</code> package for CSV files
</li>
<li>
<code>write_parquet()</code> from the <code>arrow</code> package for Parquet files
</li>
</ul>
For reading operations, we used the following functions:
<ul>
<li>
<code>readRDS()</code> for RDS files
</li>
<li>
<code>fread()</code> from the <code>data.table</code> package for CSV files
</li>
<li>
<code>read_fst()</code> from the <code>fst</code> package for FST files
</li>
<li>
<code>read_feather()</code> from the <code>arrow</code> package for Feather files
</li>
<li>
<code>qread()</code> from the <code>qs</code> package for QS files
</li>
<li>
<code>read_csv()</code> from the <code>readr</code> package for CSV files
</li>
<li>
<code>read_parquet()</code> from the <code>arrow</code> package for Parquet files
</li>
</ul>
</div>
<div id="performance-metrics" class="section level2">
<h2>Performance metrics</h2>
The performance metrics considered in our analysis are:
<ul>
<li>
The time taken to read from and write to each data format. This metric is crucial for understanding the efficiency of each format in different scenarios.
</li>
<li>
The disk space required to store the data in each format. Smaller file sizes are generally preferable, especially when dealing with large data sets.
</li>
<li>
The amount of memory consumed during the read operations. Efficient memory usage is important for handling large data sets without running into memory constraints.
</li>
</ul>
</div>
</div>
<div id="results-and-analysis" class="section level1">
<h1>Results and analysis</h1>
<p>The results of benchmarking study on various data formats in <code>R</code> include read and write time, file size, and memory usage. The results are visualized in graphs and tables, which show the performance trends as the data set size increases.</p>
<div id="file-sizes" class="section level2">
<h2>File sizes</h2>
<p>The first graph illustrates the file sizes for each data format across different data set sizes. Smaller file sizes are generally preferable as they require less disk space and can be more efficient for data transfer. The formats compared include RDS, CSV (using <code>data.table</code> and <code>readr</code>), FST, Feather, Parquet, and QS.</p>
<p><a href="post/2024-07-03-read_write_big_data/p_file_sizes.html">Interactive Plotly Plot</a></p>
From the graph, we can observe:
<ul>
<li>
QS consistently produces the smallest file sizes across all data set sizes.
</li>
<li>
RDS and FST also perform well, producing relatively small file sizes.
</li>
<li>
CSV formats (both <code>data.table</code> and <code>readr</code>) tend to produce the largest file sizes, particularly for larger data sets.
</li>
<li>
Feather and Parquet offer a balance between file size and compatibility, but their sizes increase significantly with very large data sets.
</li>
</ul>
</div>
<div id="write-performance" class="section level2">
<h2>Write performance</h2>
<p>The second graph shows the write performance for each data format. Faster write times are beneficial for efficiently saving data, particularly in workflows involving frequent data saving operations.</p>
Key observations from the graph include:
<ul>
<li>
QS and FST exhibit the fastest write times for smaller datasets, maintaining good performance even as dataset size increases.
</li>
<li>
RDS is also relatively fast, but its performance degrades more than QS and FST with larger datasets.
</li>
<li>
CSV formats, especially <code>readr</code>, show significantly slower write times, making them less suitable for large-scale data operations.
</li>
<li>
Feather and Parquet provide moderate write performance, balancing speed and compatibility with other data analysis tools.
</li>
</ul>
</div>
<div id="read-performance" class="section level2">
<h2>Read performance</h2>
<p>The third graph displays the read performance for each data format. Fast read times are critical for efficient data analysis, especially when working with large datasets that need to be frequently loaded into memory.</p>
From the graph, we note that:
<ul>
<li>
QS, FST, and RDS offer the fastest read times, making them ideal for scenarios where quick data loading is essential.
</li>
<li>
CSV formats (both <code>data.table</code> and <code>readr</code>) have slower read times, particularly for larger datasets, which can hinder performance in large-scale analyses.
</li>
<li>
Feather and Parquet provide moderate read speeds, suitable for interoperability across different tools and languages.
</li>
</ul>
</div>
<div id="memory-usage" class="section level2">
<h2>Memory usage</h2>
<p>The final graph compares the memory usage of each data format during read operations. Efficient memory usage is important for handling large datasets without encountering memory constraints.</p>
Key points from the graph include:
<ul>
<li>
QS and RDS exhibit the lowest memory usage, making them suitable for environments with limited memory resources.
</li>
<li>
FST and Feather also show good memory efficiency, particularly for smaller to moderate-sized datasets.
</li>
<li>
CSV formats, especially <code>readr</code>, consume the most memory, which can be problematic for very large datasets.
</li>
<li>
Parquet offers a balance between memory usage and interoperability, although its memory consumption increases with larger datasets.
</li>
</ul>
<p>Overall, these results provide a comprehensive comparison of different data formats in <code>R</code>, highlighting their respective strengths and weaknesses in terms of file size, read and write performance, and memory usage. This information can guide the selection of appropriate data formats based on specific analysis requirements.</p>
<p><strong>Did you find this page helpful? Consider sharing it 🙌</strong></p>
</div>
</div>
