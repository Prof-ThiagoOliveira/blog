---
title: "Tidyverse: answers"
subtitle: "Principles of graph grammar and tidy data: tidyverse exercises"
author: "Thiago de Paula Oliveira"
date: "`r Sys.Date()`"
weight: 60
highlight: true
header-includes:
  - \usepackage{amsmath}
output:
  blogdown::html_page:
    number_sections: false
    highlight: kate
    toc: true
    css: "my_style.css"
---

```{r, echo=FALSE}
htmltools::img(src = knitr::image_uri(file.path(".", "logo.png")), 
               alt = 'logo', 
               style = 'position:absolute; top:0; right:0; padding:2px; 
               height:120px; width:220px')
```

```{r setup, include=FALSE}
# Configuring global parameters
knitr::opts_chunk$set(echo = TRUE, message = FALSE, error=FALSE, warning = FALSE,
                      fig.align = "center", fig.height = 6, fig.width = 6,
                      class.source = "lineAnchors")
```


```{r, include=FALSE, message=FALSE, error=FALSE, warning=FALSE}
#=======================================================================
# Packages
#=======================================================================
if (!require("pacman")) {
  install.packages("pacman")
}
# Include all packages here
pacman::p_load(
  knitr,
  tidyverse,
  kableExtra, 
  prettycode,
  formattable,
  DT,
  AlphaSimR,
  patchwork, # ggplot design
  tufte, # quotes
  ggridges,
  pathwork,
  ggpmisc,
  egg,
  datarium,
  tools,
  gapminder
)
prettycode::prettycode()
```

# Tidy data

Tidy data refers to data arranged to make data processing, analysis, and visualization simpler. Remember that in a tidy data set we should consider:

* Each variable must have its column.
* Each observation must have its row.
* Each value must have its cell.

## Exercise 1
Letâ€™s say we want to organize the data ```anscombe```. Below I shpw how this data looks like:
```{r}
anscombe
```


1. Organize this data set to obtain tidy data. Remember here we have two response variables been measured four times. 

Most of the selecting, separating, mutating and renaming is taking place within the pivot function calls.

```{r}
(ex1 <- anscombe %>%
  pivot_longer(everything(),
               names_to = c(".value", "rep"),
               names_pattern = "(.)([0-9])"
               ))
```



2. Filter the data set to get replications 2 and 4, and summarise it to 
get the maximum, minimum, and mean values.
```{r}
ex1 %>%
  filter(rep %in% c(2,4)) %>%
  summarise(
    across(c(x,y), list(mean = mean, min = min, max = max),
           .names = "{.col}.{.fn}"
  ))
```

## Exercise 2

Often you do not need the entire data set, but just part of it. 

1. Here, you should make the data ```mtcars``` tidy before making any selection.

```{r}
(dataEx3 <- readRDS("./data/dataEx3.rds"))
```

As you can see, some columns are not variable names but values. Create two new variables calling mpg (for observations) and gear (with column values). 

```{r, eval=FALSE}
dataEx3 <- dataEx3 %>%
  pivot_longer(
   cols = matches("([1-9])"),
   names_to = "gear",
   values_to = "mpg",
   values_drop_na = TRUE
  )
```

2. Select the columns mpg, hp, gear, and carb, and then make a plot using ggplot2 where ``` mpg``` is the response variable, and ```hp``` is the co-variate in the x-axis. Also include different shapes and colours for ```gear```, and facets for ```carb```. 

```{r, eval=FALSE}
dataEx3 %>%
  select(mpg, hp, gear, carb) %>%
  ggplot(aes(y=mpg, x = hp, shape = gear,
             colour = gear)) +
  geom_point() +
  facet_wrap(~carb) +
  theme_bw()
```

# Exercise 3

The following data represents song rankings for Billboard top 100 in the year 2000. The rank of the song is displayed in each week after it entered.

```{r}
billboard
```

A slightly more complex case where columns have a common prefix and missing missings are structural, so should be dropped. So, make this data tidy.

```{r, eval=FALSE}
billboard %>%
  pivot_longer(
   cols = starts_with("wk"),
   names_to = "week",
   names_prefix = "wk",
   values_to = "rank",
   values_drop_na = TRUE
 )
```

# Data Structure

## Exercise 1

1. Make this data tidy by including ```tmin``` and ```tmax``` as variable. Remember that here type is carrying to variables names rather than factors. 

```{r}
(dataEx2 <- as_tibble(readRDS("./data/dataEx2.RDS")))
```

```{r}
(dataEx2 <- dataEx2 %>%
  pivot_wider(values_from = value, names_from = type))
```

Now, build a new variable called ```tdiff```, which is the difference between ```tmax``` and ```tmin```. Moreover, display a ```ggplot2``` graph that shows ```tdiff``` over time.

```{r, eval=FALSE}
dataEx2 %>%
  dplyr::mutate(tdiff = tmax - tmin) %>%
  ggplot(aes(y = tdiff, x = date)) +
  geom_point() +
  geom_smooth(se = FALSE) +
  ylab("tmax - tmin") + xlab ("Date") +
  theme_classic()
```


## Exercise 2

Our cattle data data is already in a tidy format.
```{r}
(cbp <- readRDS("./data/animal_sim.RDS"))
```

For this exercise, complete the following tasks with that data set:

1. Calculate the average phenotype per year by sex and herd using the ```summarise()``` function in the dplyr package.
2. Add two columns to cattle data using the ```mutate()``` function: 
    1. Column 1: Phenotype should be rescaled to have a mean of zero and a standard deviation of one. You can call this new variable as ```PhenoStd```.
    2. Column 2: Rank the ```PhenoStd``` using the function ```min_rank()```. 
    3. The output data frame should have only ```PhenoStd > 0```.

```{r}
cbp %>%
  group_by(year, sex, herd) %>%
  summarise(
    mean = mean(phenotype)
  )

.scale <- function(x){
  (x - mean(x, na.rm=TRUE)) / sd(x, na.rm=TRUE)
}

cbp %>%
  dplyr::mutate(PhenoStd = .scale(phenotype)) %>%
  dplyr::mutate(RankPhenoStd = min_rank(PhenoStd)) %>%
  filter(PhenoStd > 0)
```


## Exercise 3

Excerpt of the Gapminder data on life expectancy, GDP per capita, and population by country. This data has 142 countries observed from the year 1952 to 2007 in increments of 5 years. The response variable observed was the life expectancy at birth (in years), population size, and Per capita gross domestic product (GDP). 

Per capita gross domestic product (GDP) measures a country's economic response per person and is calculated by dividing its GDP by its population. It is a global measure for gauging the prosperity of nations as we can analyze the worth of a country based on its economic growth. Thus, countries that have the highest per capita GDP tend to be more developed.


```{r}
gapminder
```

Questions:

1. What are the ten highest ```gdpPercap``` values?

```{r}
gapminder %>%
  slice_max(gdpPercap, n = 10)
```

2. Find both the median life expectancy (```lifeExp```) and the median and maximum GDP per capita (```gdpPercap```) in 1957, 1982, and 2007, by country and continent. Call them ```medianLifeExp```, ```medianGdpPercap```, and ```maxGdpPercap```, respectively.

```{r}
(dat <- gapminder %>%
  filter(year %in% c("1957","1982","2007")) %>%
  group_by(year, country, continent) %>%
  summarise(
    medianlifeExp = median(lifeExp),
    medianGdpPercap = median(gdpPercap),
    maxGdpPercap = max(gdpPercap)
  ))
```

3. Use a scatter plot to compare the median GDP and median life expectancy. Use the variables continent and year to produce this plot.

```{r}
dat %>%
  ggplot(aes(x = medianGdpPercap, y = medianlifeExp)) +
  facet_wrap(~ continent) +
  geom_point(shape = 1)
```