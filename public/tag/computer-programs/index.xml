<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Computer Programs | Thiago Oliveira</title>
    <link>https://prof-thiagooliveira.netlify.com/tag/computer-programs/</link>
      <atom:link href="https://prof-thiagooliveira.netlify.com/tag/computer-programs/index.xml" rel="self" type="application/rss+xml" />
    <description>Computer Programs</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><copyright>Â© 2021 Thiago Oliviera</copyright><lastBuildDate>Wed, 16 Dec 2020 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://prof-thiagooliveira.netlify.com/media/icon_hua8192a3d26f52862b6ecd0fa00b0dcdd_44669_512x512_fill_lanczos_center_3.png</url>
      <title>Computer Programs</title>
      <link>https://prof-thiagooliveira.netlify.com/tag/computer-programs/</link>
    </image>
    
    <item>
      <title>Expressions in C&#43;&#43;</title>
      <link>https://prof-thiagooliveira.netlify.com/post/expressions/</link>
      <pubDate>Wed, 16 Dec 2020 00:00:00 +0000</pubDate>
      <guid>https://prof-thiagooliveira.netlify.com/post/expressions/</guid>
      <description>


&lt;div id=&#34;introduction&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;Expressions in C++ are fundamental constructs made up of operators, constants, and variables, following the languageâ€™s syntactical rules. Every expression is a segment of a code that returns a value. For instance:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;exp1.png&#34; width=&#34;320px&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;This example demonstrates the creation of variables to store values: a box for &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; and another for &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt;, where &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt; equals the expression &lt;span class=&#34;math inline&#34;&gt;\(x + 13\)&lt;/span&gt; (thus, &lt;span class=&#34;math inline&#34;&gt;\(y = 23\)&lt;/span&gt;). Now, letâ€™s delve into a more complex example:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;exp2.png&#34; width=&#34;500px&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&lt;/p&gt;
This statement encompasses three expressions:
&lt;div class=&#34;div-1&#34;&gt;
&lt;ul&gt;
&lt;li&gt;The results of the expression &lt;span class=&#34;math inline&#34;&gt;\(3 - x\)&lt;/span&gt; is stored in the variable &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;The expression &lt;span class=&#34;math inline&#34;&gt;\(y = 3 - x\)&lt;/span&gt; returns the value of &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt;, and it is stored in the variable &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;The results of the expression &lt;span class=&#34;math inline&#34;&gt;\(y \times \left(\frac{v}{5} + x\right)\)&lt;/span&gt; is stored in the variable &lt;span class=&#34;math inline&#34;&gt;\(z\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;Itâ€™s essential to remember the precedence of operations: multiplication and division are executed before addition and subtraction. For example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1-3*4 = -11
2/3-4*2/3 = -2
2/3-4/4*2/3 = 0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Operator precedence&lt;/strong&gt; in &lt;code&gt;C++&lt;/code&gt; determines the sequence of operations in an expression. Operators have a specific order of execution relative to others. For instance, in the expression &lt;span class=&#34;math inline&#34;&gt;\(\frac{2}{4} - 3 + 4 \times 6\)&lt;/span&gt;, the subexpressions &lt;span class=&#34;math inline&#34;&gt;\(\frac{2}{4}\)&lt;/span&gt;&lt;code&gt;and&lt;/code&gt;&lt;span class=&#34;math inline&#34;&gt;\(4 \times 6\)&lt;/span&gt; are calculated first, followed by the addition and subtraction. When operators have the same precedence, their associativity dictates the order - either left-to-right or right-to-left.&lt;/p&gt;
&lt;div class=&#34;figure&#34; style=&#34;text-align: center&#34;&gt;&lt;span style=&#34;display:block;&#34; id=&#34;fig:unnamed-chunk-3&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;exp3.png&#34; alt=&#34;Precedence order&#34; width=&#34;300px&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figure 1: Precedence order
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Associativity&lt;/strong&gt; specifies the order of operations for operators with the same precedence level. It can be left-to-right or right-to-left. Typically, addition, subtraction, multiplication, and division are left-associative, while assignment operators are right-associative. Some operators are non-associative, meaning their behaviour is undefined if used sequentially in an expression. Parentheses can alter the default associativity, enforcing a specific order.&lt;/p&gt;
&lt;div class=&#34;figure&#34; style=&#34;text-align: center&#34;&gt;&lt;span style=&#34;display:block;&#34; id=&#34;fig:unnamed-chunk-4&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;exp4.png&#34; alt=&#34;Example of left-associative, right-associative, and non-associative&#34; width=&#34;800px&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figure 2: Example of left-associative, right-associative, and non-associative
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;using-parentheses&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Using Parentheses &lt;code&gt;()&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;The operator &lt;code&gt;()&lt;/code&gt; has the highest precedente order (see &lt;a href=&#34;#table1&#34;&gt;Table 1&lt;/a&gt;), as consequence, we can use parentheses to change the sequence of operators.
Consider the following example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;5 + 6 * 7&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;*&lt;/code&gt; operator is evaluated firstly, followed by the &lt;code&gt;+&lt;/code&gt; operator, so the result is &lt;span class=&#34;math inline&#34;&gt;\(5+6\times 7 = 47\)&lt;/span&gt;. However, if we want to account for the addiction first and then the multiplication, we can rewrite the code as:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(5 + 6) * 7&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then, the program will compute &lt;span class=&#34;math inline&#34;&gt;\(\left(5+6\right)\times 7=11\times 7=77\)&lt;/span&gt;. Sometimes, parenthesesâ€™ inclusion should be important to make your code easier to understand, and therefore easier to maintain.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;modulus-operator&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Modulus operator (%)&lt;/h1&gt;
The modulus operator evaluates the remainder when dividing the first operand by the second one. Ex.: &lt;code&gt;a % b&lt;/code&gt; is the remainder when &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; is divided
&lt;table class=&#34;wikitable&#34;&gt;
by &lt;span class=&#34;math inline&#34;&gt;\(b\)&lt;/span&gt; (&lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; modulus &lt;span class=&#34;math inline&#34;&gt;\(b\)&lt;/span&gt;).
&lt;table class=&#34;wikitable&#34;&gt;
&lt;p&gt;by &lt;span class=&#34;math inline&#34;&gt;\(b\)&lt;/span&gt; (&lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; modulus &lt;span class=&#34;math inline&#34;&gt;\(b\)&lt;/span&gt;).&lt;/p&gt;
&lt;div class=&#34;figure&#34; style=&#34;text-align: center&#34;&gt;&lt;span style=&#34;display:block;&#34; id=&#34;fig:unnamed-chunk-5&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;exp5.png&#34; alt=&#34;Example of modulus&#34; width=&#34;300px&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figure 3: Example of modulus
&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;div-1&#34;&gt;
&lt;ul&gt;
&lt;li&gt;Dividing an integer by another one gives an integer.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;example&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Example:&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;int x = 10;
int y = 3;

x/y = 10/3 = 3 (dividing two integers)

x % y = 1 (modulus)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;short-hand-or-syntatic-sugar&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Short hand or syntatic sugar&lt;/h1&gt;
&lt;p&gt;Short hand expressions provide a straightforward way to write common patterns over the algorithm for initialized variables.&lt;/p&gt;
&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;15%&#34; /&gt;
&lt;col width=&#34;21%&#34; /&gt;
&lt;col width=&#34;62%&#34; /&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th&gt;Short hand&lt;/th&gt;
&lt;th&gt;Meaning&lt;/th&gt;
&lt;th&gt;Prefix and Postfix&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;span class=&#34;math inline&#34;&gt;\(x+=y\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&#34;math inline&#34;&gt;\(x=x+y\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;span class=&#34;math inline&#34;&gt;\(x-=y\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&#34;math inline&#34;&gt;\(x=x-y\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;span class=&#34;math inline&#34;&gt;\(x*=y\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&#34;math inline&#34;&gt;\(x= x \times y\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;span class=&#34;math inline&#34;&gt;\(x/=y\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&#34;math inline&#34;&gt;\(x=x/y\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;span class=&#34;math inline&#34;&gt;\(x++\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&#34;math inline&#34;&gt;\(x=x+1\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;Return the value of &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; first then increment it&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;span class=&#34;math inline&#34;&gt;\(++x\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&#34;math inline&#34;&gt;\(x=x+1\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;Increment first then return the value of &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;span class=&#34;math inline&#34;&gt;\(x--\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&#34;math inline&#34;&gt;\(x=x-1\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;Return the value of &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; first then increment it&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;span class=&#34;math inline&#34;&gt;\(--x\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&#34;math inline&#34;&gt;\(x=x-1\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;Increment first then return the value of &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div id=&#34;example-1&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Example 1:&lt;/h2&gt;
&lt;p&gt;Here you can see that &lt;code&gt;y ++= x * z;&lt;/code&gt; is calculate as &lt;span class=&#34;math inline&#34;&gt;\(y=y+x \times z = 30 + 2 \times 4 = 38\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;example1.png&#34; width=&#34;350px&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;example-2&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Example 2:&lt;/h2&gt;
&lt;p&gt;In this example you can see that we used the postfix &lt;code&gt;x++&lt;/code&gt; to first initialize &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt; (&lt;span class=&#34;math inline&#34;&gt;\(y=8 \times x = 8 \times 7 = 56\)&lt;/span&gt;) and then update &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; to &lt;code&gt;x=x+1=8&lt;/code&gt;. On the other hand, we used the prefix &lt;code&gt;--y&lt;/code&gt; to first update the variable &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt; to &lt;code&gt;y=y-1=55&lt;/code&gt; and then calculate the variable z using the updated &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt; &lt;span class=&#34;math inline&#34;&gt;\(\left(z = y/5 = 55/5 = 11 \right)\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;example2.png&#34; width=&#34;500px&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Note that when we use &lt;code&gt;x*= (y/z) % 2&lt;/code&gt; the variable &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; multiply the entire expression after &lt;code&gt;=&lt;/code&gt; symbol. This expression is equivalent to &lt;code&gt;x = x * ((y/z) % 2));&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;operator-precedence-and-associativity&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Operator precedence and associativity&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;#table1&#34;&gt;Table 1&lt;/a&gt; shows a list of precedence (ordered) and associativity of C operators. This table was obtained from
&lt;a href=&#34;https://en.cppreference.com/w/c/language/operator_precedence#cite_note-1&#34;&gt;cppreference.com&lt;/a&gt;.&lt;/p&gt;
&lt;div&gt;
&lt;table class=&#34;wikitable&#34;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;a name=&#34;table1&#34;&gt; Table 1: Precedence and associativity of C operators &lt;/a&gt;
&lt;th style=&#34;text-align: left&#34;&gt;
Precedence
&lt;/th&gt;
&lt;th style=&#34;text-align: left&#34;&gt;
Operator
&lt;/th&gt;
&lt;th style=&#34;text-align: left&#34;&gt;
Description
&lt;/th&gt;
&lt;th style=&#34;text-align: left&#34;&gt;
Associativity
&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th rowspan=&#34;6&#34;&gt;
1
&lt;/th&gt;
&lt;td style=&#34;border-bottom-style: none&#34;&gt;
&lt;code&gt;++&lt;/code&gt; &lt;code&gt;--&lt;/code&gt;
&lt;/td&gt;
&lt;td style=&#34;border-bottom-style: none&#34;&gt;
Suffix/postfix increment and decrement
&lt;/td&gt;
&lt;td style=&#34;vertical-align: top&#34; rowspan=&#34;6&#34;&gt;
Left-to-right
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-bottom-style: none; border-top-style: none&#34;&gt;
&lt;code&gt;()&lt;/code&gt;
&lt;/td&gt;
&lt;td style=&#34;border-bottom-style: none; border-top-style: none&#34;&gt;
Function call
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-bottom-style: none; border-top-style: none&#34;&gt;
&lt;code&gt;[]&lt;/code&gt;
&lt;/td&gt;
&lt;td style=&#34;border-bottom-style: none; border-top-style: none&#34;&gt;
Array subscripting
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-bottom-style: none; border-top-style: none&#34;&gt;
&lt;code&gt;.&lt;/code&gt;
&lt;/td&gt;
&lt;td style=&#34;border-bottom-style: none; border-top-style: none&#34;&gt;
Structure and union member access
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-bottom-style: none; border-top-style: none&#34;&gt;
&lt;code&gt;-&amp;gt;&lt;/code&gt;
&lt;/td&gt;
&lt;td style=&#34;border-bottom-style: none; border-top-style: none&#34;&gt;
Structure and union member access through pointer
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-bottom-style: none; border-top-style: none&#34;&gt;
&lt;code&gt;(&lt;i&gt;type&lt;/i&gt;){&lt;i&gt;list&lt;/i&gt;}&lt;/code&gt;
&lt;/td&gt;
&lt;td style=&#34;border-bottom-style: none; border-top-style: none&#34;&gt;
Compound literal&lt;span class=&#34;t-mark-rev t-since-c99&#34;&gt;(C99)&lt;/span&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th rowspan=&#34;8&#34;&gt;
2
&lt;/th&gt;
&lt;td style=&#34;border-bottom-style: none&#34;&gt;
&lt;code&gt;++&lt;/code&gt; &lt;code&gt;--&lt;/code&gt;
&lt;/td&gt;
&lt;td style=&#34;border-bottom-style: none&#34;&gt;
Prefix increment and decrement&lt;sup id=&#34;cite_ref-1&#34; class=&#34;reference&#34;&gt;&lt;a href=&#34;#cite_note-1&#34;&gt;[note 1]&lt;/a&gt;&lt;/sup&gt;
&lt;/td&gt;
&lt;td style=&#34;vertical-align: top&#34; rowspan=&#34;8&#34;&gt;
Right-to-left
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-bottom-style: none; border-top-style: none&#34;&gt;
&lt;code&gt;+&lt;/code&gt; &lt;code&gt;-&lt;/code&gt;
&lt;/td&gt;
&lt;td style=&#34;border-bottom-style: none; border-top-style: none&#34;&gt;
Unary plus and minus
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-bottom-style: none; border-top-style: none&#34;&gt;
&lt;code&gt;!&lt;/code&gt; &lt;code&gt;~&lt;/code&gt;
&lt;/td&gt;
&lt;td style=&#34;border-bottom-style: none; border-top-style: none&#34;&gt;
Logical NOT and bitwise NOT
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-bottom-style: none; border-top-style: none&#34;&gt;
&lt;code&gt;(&lt;i&gt;type&lt;/i&gt;)&lt;/code&gt;
&lt;/td&gt;
&lt;td style=&#34;border-bottom-style: none; border-top-style: none&#34;&gt;
Cast
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-bottom-style: none; border-top-style: none&#34;&gt;
&lt;code&gt;*&lt;/code&gt;
&lt;/td&gt;
&lt;td style=&#34;border-bottom-style: none; border-top-style: none&#34;&gt;
Indirection (dereference)
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-bottom-style: none; border-top-style: none&#34;&gt;
&lt;code&gt;&amp;amp;&lt;/code&gt;
&lt;/td&gt;
&lt;td style=&#34;border-bottom-style: none; border-top-style: none&#34;&gt;
Address-of
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-bottom-style: none; border-top-style: none&#34;&gt;
&lt;code&gt;sizeof&lt;/code&gt;
&lt;/td&gt;
&lt;td style=&#34;border-bottom-style: none; border-top-style: none&#34;&gt;
Size-of&lt;sup id=&#34;cite_ref-2&#34; class=&#34;reference&#34;&gt;&lt;a href=&#34;#cite_note-2&#34;&gt;[note 2]&lt;/a&gt;&lt;/sup&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-bottom-style: none; border-top-style: none&#34;&gt;
&lt;code&gt;_Alignof&lt;/code&gt;
&lt;/td&gt;
&lt;td style=&#34;border-bottom-style: none; border-top-style: none&#34;&gt;
Alignment requirement&lt;span class=&#34;t-mark-rev t-since-c11&#34;&gt;(C11)&lt;/span&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
3
&lt;/th&gt;
&lt;td&gt;
&lt;code&gt;*&lt;/code&gt; &lt;code&gt;/&lt;/code&gt; &lt;code&gt;%&lt;/code&gt;
&lt;/td&gt;
&lt;td&gt;
Multiplication, division, and remainder
&lt;/td&gt;
&lt;td style=&#34;vertical-align: top&#34; rowspan=&#34;11&#34;&gt;
Left-to-right
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
4
&lt;/th&gt;
&lt;td&gt;
&lt;code&gt;+&lt;/code&gt; &lt;code&gt;-&lt;/code&gt;
&lt;/td&gt;
&lt;td&gt;
Addition and subtraction
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
5
&lt;/th&gt;
&lt;td&gt;
&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;
&lt;/td&gt;
&lt;td&gt;
Bitwise left shift and right shift
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th rowspan=&#34;2&#34;&gt;
6
&lt;/th&gt;
&lt;td style=&#34;border-bottom-style: none&#34;&gt;
&lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;&amp;lt;=&lt;/code&gt;
&lt;/td&gt;
&lt;td style=&#34;border-bottom-style: none&#34;&gt;
For relational operators &amp;lt; and â‰¤ respectively
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-top-style: none&#34;&gt;
&lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;gt;=&lt;/code&gt;
&lt;/td&gt;
&lt;td style=&#34;border-top-style: none&#34;&gt;
For relational operators &amp;gt; and â‰¥ respectively
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
7
&lt;/th&gt;
&lt;td&gt;
&lt;code&gt;==&lt;/code&gt; &lt;code&gt;!=&lt;/code&gt;
&lt;/td&gt;
&lt;td&gt;
For relational = and â‰  respectively
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
8
&lt;/th&gt;
&lt;td&gt;
&lt;code&gt;&amp;amp;&lt;/code&gt;
&lt;/td&gt;
&lt;td&gt;
Bitwise AND
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
9
&lt;/th&gt;
&lt;td&gt;
&lt;code&gt;^&lt;/code&gt;
&lt;/td&gt;
&lt;td&gt;
Bitwise XOR (exclusive or)
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
10
&lt;/th&gt;
&lt;td&gt;
&lt;code&gt;|&lt;/code&gt;
&lt;/td&gt;
&lt;td&gt;
Bitwise OR (inclusive or)
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
11
&lt;/th&gt;
&lt;td&gt;
&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;
&lt;/td&gt;
&lt;td&gt;
Logical AND
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
12
&lt;/th&gt;
&lt;td&gt;
&lt;code&gt;||&lt;/code&gt;
&lt;/td&gt;
&lt;td&gt;
Logical OR
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
13
&lt;/th&gt;
&lt;td&gt;
&lt;code&gt;?:&lt;/code&gt;
&lt;/td&gt;
&lt;td&gt;
Ternary conditional&lt;sup id=&#34;cite_ref-3&#34; class=&#34;reference&#34;&gt;&lt;a href=&#34;#cite_note-3&#34;&gt;[note 3]&lt;/a&gt;&lt;/sup&gt;
&lt;/td&gt;
&lt;td style=&#34;vertical-align: top&#34; rowspan=&#34;6&#34;&gt;
Right-to-Left
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th rowspan=&#34;5&#34;&gt;
14&lt;sup id=&#34;cite_ref-4&#34; class=&#34;reference&#34;&gt;&lt;a href=&#34;#cite_note-4&#34;&gt;[note 4]&lt;/a&gt;&lt;/sup&gt;
&lt;/th&gt;
&lt;td style=&#34;border-bottom-style: none&#34;&gt;
&lt;code&gt;=&lt;/code&gt;
&lt;/td&gt;
&lt;td style=&#34;border-bottom-style: none&#34;&gt;
Simple assignment
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-bottom-style: none; border-top-style: none&#34;&gt;
&lt;code&gt;+=&lt;/code&gt; &lt;code&gt;-=&lt;/code&gt;
&lt;/td&gt;
&lt;td style=&#34;border-bottom-style: none; border-top-style: none&#34;&gt;
Assignment by sum and difference
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-bottom-style: none; border-top-style: none&#34;&gt;
&lt;code&gt;*=&lt;/code&gt; &lt;code&gt;/=&lt;/code&gt; &lt;code&gt;%=&lt;/code&gt;
&lt;/td&gt;
&lt;td style=&#34;border-bottom-style: none; border-top-style: none&#34;&gt;
Assignment by product, quotient, and remainder
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-bottom-style: none; border-top-style: none&#34;&gt;
&lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt; &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;
&lt;/td&gt;
&lt;td style=&#34;border-bottom-style: none; border-top-style: none&#34;&gt;
Assignment by bitwise left shift and right shift
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;border-top-style: none&#34;&gt;
&lt;code&gt;&amp;amp;=&lt;/code&gt; &lt;code&gt;^=&lt;/code&gt; &lt;code&gt;|=&lt;/code&gt;
&lt;/td&gt;
&lt;td style=&#34;border-top-style: none&#34;&gt;
Assignment by bitwise AND, XOR, and OR
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;
15
&lt;/th&gt;
&lt;td&gt;
&lt;code&gt;,&lt;/code&gt;
&lt;/td&gt;
&lt;td&gt;
Comma
&lt;/td&gt;
&lt;td&gt;
Left-to-right
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ol class=&#34;references&#34;&gt;
&lt;li id=&#34;cite_note-1&#34;&gt;
&lt;span class=&#34;mw-cite-backlink&#34;&gt;&lt;a href=&#34;#cite_ref-1&#34;&gt;â†‘&lt;/a&gt;&lt;/span&gt; &lt;span class=&#34;reference-text&#34;&gt;The operand of prefix &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; canâ€™t be a type cast. This rule grammatically forbids some expressions that would be semantically invalid anyway. Some compilers ignore this rule and detect the invalidity semantically.&lt;/span&gt;
&lt;/li&gt;
&lt;li id=&#34;cite_note-2&#34;&gt;
&lt;span class=&#34;mw-cite-backlink&#34;&gt;&lt;a href=&#34;#cite_ref-2&#34;&gt;â†‘&lt;/a&gt;&lt;/span&gt; &lt;span class=&#34;reference-text&#34;&gt;The operand of &lt;code&gt;sizeof&lt;/code&gt; canâ€™t be a type cast: the expression &lt;code&gt;sizeof (int) * p&lt;/code&gt; is unambiguously interpreted as &lt;code&gt;(sizeof(int)) * p&lt;/code&gt;, but not &lt;code&gt;sizeof((int)*p)&lt;/code&gt;.&lt;/span&gt;
&lt;/li&gt;
&lt;li id=&#34;cite_note-3&#34;&gt;
&lt;span class=&#34;mw-cite-backlink&#34;&gt;&lt;a href=&#34;#cite_ref-3&#34;&gt;â†‘&lt;/a&gt;&lt;/span&gt; &lt;span class=&#34;reference-text&#34;&gt;The expression in the middle of the conditional operator (between &lt;code&gt;&lt;b&gt;?&lt;/b&gt;&lt;/code&gt; and &lt;code&gt;&lt;b&gt;:&lt;/b&gt;&lt;/code&gt;) is parsed as if parenthesized: its precedence relative to &lt;code&gt;?:&lt;/code&gt; is ignored.&lt;/span&gt;
&lt;/li&gt;
&lt;li id=&#34;cite_note-4&#34;&gt;
&lt;span class=&#34;mw-cite-backlink&#34;&gt;&lt;a href=&#34;#cite_ref-4&#34;&gt;â†‘&lt;/a&gt;&lt;/span&gt; &lt;span class=&#34;reference-text&#34;&gt;Assignment operatorsâ€™ left operands must be unary (level-2 non-cast) expressions. This rule grammatically forbids some expressions that would be semantically invalid anyway. Many compilers ignore this rule and detect the invalidity semantically. For example, &lt;span class=&#34;t-c&#34;&gt;&lt;span class=&#34;mw-geshi c source-c&#34;&gt;e &lt;span class=&#34;sy1&#34;&gt;=&lt;/span&gt; a &lt;span class=&#34;sy1&#34;&gt;&amp;lt;&lt;/span&gt; d &lt;span class=&#34;sy4&#34;&gt;?&lt;/span&gt; a&lt;span class=&#34;sy2&#34;&gt;++&lt;/span&gt; &lt;span class=&#34;sy4&#34;&gt;:&lt;/span&gt; a &lt;span class=&#34;sy1&#34;&gt;=&lt;/span&gt; d&lt;/span&gt;&lt;/span&gt; is an expression that cannot be parsed because of this rule. However, many compilers ignore this rule and parse it as &lt;span class=&#34;t-c&#34;&gt;&lt;span class=&#34;mw-geshi c source-c&#34;&gt;e &lt;span class=&#34;sy1&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;br0&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;br0&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;br0&#34;&gt;(&lt;/span&gt;a &lt;span class=&#34;sy1&#34;&gt;&amp;lt;&lt;/span&gt; d&lt;span class=&#34;br0&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;sy4&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;br0&#34;&gt;(&lt;/span&gt;a&lt;span class=&#34;sy2&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;br0&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;sy4&#34;&gt;:&lt;/span&gt; a&lt;span class=&#34;br0&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;sy1&#34;&gt;=&lt;/span&gt; d &lt;span class=&#34;br0&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;, and then give an error because it is semantically invalid.&lt;/span&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div id=&#34;impact-of-data-types-on-expressions&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Impact of Data Types on Expressions&lt;/h2&gt;
&lt;p&gt;In &lt;code&gt;C++&lt;/code&gt;, the data type of the variables involved in an expression significantly impacts the result. For instance, dividing two integers results in an integer, while using at least one floating-point number yields a floating-point result. Understanding how data types interact within expressions is crucial for accurate calculations and avoiding common pitfalls like integer truncation.&lt;/p&gt;
&lt;p&gt;Here are some key points about integer truncation and other common pitfalls in C++:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Integer Truncation&lt;/strong&gt;: This occurs when the result of a division or other operation between integers is a floating-point number, but the data type is an integer. For example, &lt;code&gt;int result = 5 / 2;&lt;/code&gt; will store &lt;code&gt;2&lt;/code&gt; in &lt;code&gt;result&lt;/code&gt;, not &lt;code&gt;2.5&lt;/code&gt;, as the fractional part is truncated.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Implicit Type Conversions&lt;/strong&gt;: &lt;code&gt;C++&lt;/code&gt; automatically converts types in certain situations, which can lead to unexpected results. For instance, mixing signed and unsigned integers in expressions can cause unexpected behaviours due to implicit type conversions.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Overflow and Underflow&lt;/strong&gt;: This happens when a variable is assigned a value outside its range. For example, storing a value larger than the maximum value that an &lt;code&gt;int&lt;/code&gt; can hold will result in overflow, leading to unexpected values.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Precision Loss in Floating-Point Numbers&lt;/strong&gt;: Floating-point variables can lose precision, especially when dealing with very large or very small numbers. This can result in rounding errors in calculations.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Division by Zero&lt;/strong&gt;: This can occur if a program inadvertently divides a number by zero. Itâ€™s a critical error in &lt;code&gt;C++&lt;/code&gt; and can cause a program to crash or behave unpredictably.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Uninitialized Variables&lt;/strong&gt;: Using variables before initializing them can lead to unpredictable results, as they may contain random data.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Pointer Errors&lt;/strong&gt;: Common mistakes with pointers include dereferencing a null or uninitialized pointer, pointer arithmetic errors, and memory leaks.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Operator Precedence Mistakes&lt;/strong&gt;: Misunderstanding the order in which operations are performed can lead to bugs. For example, assuming that &lt;code&gt;a + b * c&lt;/code&gt; adds &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; before multiplying by &lt;code&gt;c&lt;/code&gt; (it doesnâ€™t; multiplication is done first).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Assuming Size of Data Types is Constant&lt;/strong&gt;: The size of data types like &lt;code&gt;int&lt;/code&gt; can vary depending on the system. Assuming a constant size can lead to errors, particularly when performing operations like bit manipulation or working with binary file formats.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Not Checking the Return Value of Functions&lt;/strong&gt;: When functions return values to indicate success or failure, not checking these can lead to the program continuing as if nothing went wrong, even when errors have occurred.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div id=&#34;role-of-type-casting-in-expressions&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Role of Type Casting in Expressions&lt;/h2&gt;
&lt;p&gt;Type casting in expressions can be used to explicitly convert data from one type to another. This technique is particularly useful in situations where operations between different data types are necessary. For example, casting an integer to a float in a division operation to obtain a floating-point result. However, itâ€™s important to use type casting judiciously to maintain the precision and integrity of data.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;the-significance-of-expression-evaluation-order&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;The Significance of Expression Evaluation Order&lt;/h2&gt;
&lt;p&gt;While operator precedence and associativity rules dictate the order of operations in an expression, the sequence in which expressions are evaluated can also be influenced by function calls, side effects, and sequence points. Understanding how &lt;code&gt;C++&lt;/code&gt; evaluates expressions, especially in complex statements, is essential for debugging and writing predictable code.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;compiler-optimizations-and-expressions&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Compiler Optimizations and Expressions&lt;/h2&gt;
&lt;p&gt;Modern &lt;code&gt;C++&lt;/code&gt; compilers often optimize expressions to enhance performance. These optimizations might include reordering operations (while respecting the language rules), eliminating redundant calculations, or simplifying expressions at compile time. Being aware of these potential optimizations can help in writing more efficient code and understanding any discrepancies between the written code and its execution behaviour.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;best-practices-for-writing-expressions&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Best Practices for Writing Expressions&lt;/h2&gt;
&lt;p&gt;To maintain readability and reduce errors in &lt;code&gt;C++&lt;/code&gt;, itâ€™s advisable to write clear and simple expressions. Avoid overly complex expressions, use parentheses to clarify order of operations, and follow coding standards and guidelines. Readable expressions are easier to debug, maintain, and understand, especially in collaborative environments.&lt;/p&gt;
&lt;p&gt;Adding these paragraphs can provide a more comprehensive and nuanced understanding of expressions in &lt;code&gt;C++&lt;/code&gt;, catering to both beginners and experienced programmers.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;references&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;References&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;C Operator Precedence - &lt;a href=&#34;https://en.cppreference.com/w/c/language/operator_precedence#cite_note-1&#34; class=&#34;uri&#34;&gt;https://en.cppreference.com/w/c/language/operator_precedence#cite_note-1&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;citation&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Citation&lt;/h1&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;For attribution, please cite this work as:&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;div-1&#34;&gt;
&lt;p&gt;Oliveira T.P. (2020, Dec.Â 16). Expressions in C++&lt;/p&gt;
&lt;/div&gt;
&lt;ol start=&#34;2&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;BibTeX citation&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;@misc{oliveira2020expression,
  author = {Oliveira, Thiago},
  title = {Expressions in C++},
  url = {https://prof-thiagooliveira.netlify.app/post/expressions/},
  year = {2020}
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Did you find this page helpful? Consider sharing it ðŸ™Œ&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Signed and Unsigned Binary Numbers</title>
      <link>https://prof-thiagooliveira.netlify.com/post/signed-and-unsigned-binary-numbers/</link>
      <pubDate>Wed, 16 Dec 2020 00:00:00 +0000</pubDate>
      <guid>https://prof-thiagooliveira.netlify.com/post/signed-and-unsigned-binary-numbers/</guid>
      <description>
&lt;script src=&#34;https://prof-thiagooliveira.netlify.com/post/signed-and-unsigned-binary-numbers/index.en_files/kePrint/kePrint.js&#34;&gt;&lt;/script&gt;
&lt;link href=&#34;https://prof-thiagooliveira.netlify.com/post/signed-and-unsigned-binary-numbers/index.en_files/lightable/lightable.css&#34; rel=&#34;stylesheet&#34; /&gt;


&lt;div id=&#34;introduction&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;When programming in C, a fundamental step is understanding variable assignment. C offers various data types, and here we focus on &lt;code&gt;int&lt;/code&gt;, used for integer data. There are two primary methods to define an &lt;code&gt;int&lt;/code&gt; variable:&lt;/p&gt;
&lt;div class=&#34;div-1&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Uninitialized Variable&lt;/strong&gt;: Defined simply as &lt;code&gt;int x;&lt;/code&gt;, this approach does not assign an initial value to the variable &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; (Figure 1). Itâ€™s generally advisable to avoid this since it can lead to bugs if &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; remains unassigned throughout the code.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Initialized Variable&lt;/strong&gt;: Assigning a value to &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; can be done in two ways (Figure 1):
&lt;div class=&#34;div-2&#34;&gt;
&lt;ul&gt;
&lt;li&gt;Single-step declaration - &lt;code&gt;int x = 3;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Two-step declaration - First, declare with &lt;code&gt;int x;&lt;/code&gt; then assign with &lt;code&gt;x = 3;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&#34;figure&#34; style=&#34;text-align: center&#34;&gt;&lt;span style=&#34;display:block;&#34; id=&#34;fig:unnamed-chunk-1&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;var_and_exp.png&#34; alt=&#34;Declaring variables in C&#34; width=&#34;550px&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figure 1: Declaring variables in C
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Additionally, C provides various storage sizes for integer variables. We will briefly introduce this concept. Figure 2 illustrates the representation of integers, either as whole numbers or fixed-point numbers (with a fixed number of digits). Typically, computers use a set number of bits to represent these integers. Common bit-lengths for integers include 8-bit, 16-bit (&lt;code&gt;short&lt;/code&gt;), 32-bit (&lt;code&gt;long&lt;/code&gt;), or 64-bit (&lt;code&gt;long long&lt;/code&gt;). There are two main schemes for integer representation: the signed integer type (&lt;code&gt;signed int&lt;/code&gt;), which can store values ranging from -32,767 to 32,767, and the unsigned integer type (&lt;code&gt;unsigned int&lt;/code&gt;), which encompasses values from 0 to 65,535 (calculated as &lt;span class=&#34;math inline&#34;&gt;\(32767 \times 2 + 1\)&lt;/span&gt;). The &lt;code&gt;unsigned&lt;/code&gt; qualifier is particularly useful when dealing exclusively with positive values.&lt;/p&gt;
&lt;div class=&#34;figure&#34; style=&#34;text-align: center&#34;&gt;&lt;span style=&#34;display:block;&#34; id=&#34;fig:unnamed-chunk-2&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;binary_number.png&#34; alt=&#34;Integer Representation&#34; width=&#34;500px&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figure 2: Integer Representation
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Furthermore, there are three representation schemes for signed integers: &lt;em&gt;Sign-Magnitude Representation&lt;/em&gt;, &lt;em&gt;1â€™s Complement Representation&lt;/em&gt;, and &lt;em&gt;2â€™s Complement Representation&lt;/em&gt;. These schemes are crucial for representing negative numbers in binary form. In all these schemes, positive signed binary numbers begin with a 0, while negative numbers start with a 1 (Figure 3).&lt;/p&gt;
&lt;div class=&#34;figure&#34; style=&#34;text-align: center&#34;&gt;&lt;span style=&#34;display:block;&#34; id=&#34;fig:unnamed-chunk-3&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;sign_bit.png&#34; alt=&#34;Signed binary numbers&#34; width=&#34;300px&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figure 3: Signed binary numbers
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;A limitation of signed binary numbers is that one bit is dedicated to indicating the sign (positive or negative), leaving the remaining &lt;span class=&#34;math inline&#34;&gt;\(n-1\)&lt;/span&gt; bits for the numberâ€™s magnitude, ranging from &lt;span class=&#34;math inline&#34;&gt;\(-2^{n-1}\)&lt;/span&gt; to &lt;span class=&#34;math inline&#34;&gt;\(2^{n-1}\)&lt;/span&gt;. For instance, in an 8-bit signed binary number, one bit is for the sign, and the remaining seven bits are for the magnitude:&lt;/p&gt;
&lt;div class=&#34;div-1&#34;&gt;
&lt;ul&gt;
&lt;li&gt;With Sign-Magnitude Representation:
&lt;span class=&#34;math display&#34;&gt;\[ -|2^{(8-1)}-1| \mbox{ to } 2^{(8-1)}-1 = -127 \mbox{ to } 127 \]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;With 2â€™s Complement Representation:
&lt;span class=&#34;math display&#34;&gt;\[ -2^{(8-1)} \mbox{ to } 2^{(8-1)}-1 = -128 \mbox{ to } 127 \]&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;Therefore, using 2â€™s Complement Representation, we can represent numbers from -128 to 127. You might wonder why thereâ€™s an additional number in the range with 2â€™s Complement. The answer lies in the unique way this representation handles the negative of the lowest negative number, which can be seen in Figure 4.&lt;/p&gt;
&lt;div class=&#34;figure&#34; style=&#34;text-align: center&#34;&gt;&lt;span style=&#34;display:block;&#34; id=&#34;fig:unnamed-chunk-4&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;repre_scheme.png&#34; alt=&#34;Representation schemes of Sign-Magnitude Representation and 2&#39;s Complement Representation&#34; width=&#34;400px&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figure 4: Representation schemes of Sign-Magnitude Representation and 2â€™s Complement Representation
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;dive-into-the-world-of-integer-representations&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Dive Into the World of Integer Representations!&lt;/h1&gt;
&lt;p&gt;Embark on an exhilarating journey through the binary landscape of computer science! Weâ€™re set to explore the intricate ways of representing integers, both unsigned and signed, using the power of binary digits. This adventure will take us through two riveting examples, complete with R code snippets for a hands-on experience!&lt;/p&gt;
&lt;div id=&#34;unveiling-the-unsigned-integers&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Unveiling the Unsigned Integers&lt;/h2&gt;
&lt;p&gt;Picture a sequence of numbers &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;, where &lt;span class=&#34;math inline&#34;&gt;\(x \in \lbrace 0, 1, \ldots, 15 \rbrace\)&lt;/span&gt;. Weâ€™re about to represent these numbers as 4-bit unsigned integers. Imagine this: &lt;strong&gt;4 bits&lt;/strong&gt;, each a 0 or 1, combining in myriad ways to encapsulate numbers from 0 to 15. Our journey here explores the interval &lt;span class=&#34;math inline&#34;&gt;\([0, 2^{4}âˆ’1] \in \mathcal{N}_{0}\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Hereâ€™s an R snippet to visualize this transformation:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;## Warning: package &amp;#39;kableExtra&amp;#39; was built under R version 4.2.3&lt;/code&gt;&lt;/pre&gt;
&lt;table class=&#34;table table-striped table-hover&#34; style=&#34;margin-left: auto; margin-right: auto;&#34;&gt;
&lt;caption&gt;
&lt;span id=&#34;tab:unnamed-chunk-5&#34;&gt;Table 1: &lt;/span&gt;Representation of numbers from 0 to 15 in 4 bits
&lt;/caption&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;font-weight: bold;border-right:1px solid;&#34;&gt;
bits
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
0000
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
0001
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
0010
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
0011
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
0100
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
0101
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
0110
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
0111
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
1000
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
1001
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
1010
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
1011
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
1100
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
1101
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
1110
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
1111
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;font-weight: bold;border-right:1px solid;&#34;&gt;
x
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
0
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
1
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
2
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
3
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
4
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
5
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
6
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
7
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
8
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
9
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
10
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
11
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
12
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
13
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
14
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
15
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Prepare to be amazed as simple integers transform into a beautiful array of zeros and ones!&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;deciphering-signed-integers&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Deciphering Signed Integers&lt;/h2&gt;
&lt;p&gt;Next, letâ€™s step into the world of signed integers, representing a sequence &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt; within &lt;span class=&#34;math inline&#34;&gt;\(\{-7, -6, \ldots, 6, 7\}\)&lt;/span&gt;. With 4 bits at our disposal, one bit becomes the &lt;strong&gt;sign bit&lt;/strong&gt;, while the remaining three are &lt;strong&gt;magnitude bits&lt;/strong&gt;. This setup enables us to span &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt; within the range &lt;span class=&#34;math inline&#34;&gt;\(\left[-|2^3-1|, 2^3-1\right] \in \mathcal{Z}\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Witness the Sign-Magnitude Representation, where the first bit unveils the sign, and the rest narrate the magnitude:&lt;/p&gt;
&lt;table class=&#34;table table-striped table-hover&#34; style=&#34;margin-left: auto; margin-right: auto;&#34;&gt;
&lt;caption&gt;
&lt;span id=&#34;tab:unnamed-chunk-6&#34;&gt;Table 2: &lt;/span&gt;Sign-Magnitude Representation of numbers from -7 to 7 using 4 bits
&lt;/caption&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;font-weight: bold;border-right:1px solid;&#34;&gt;
bits
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
0111
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
0110
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
0101
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
0100
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
0011
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
0010
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
0001
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
0000
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
1000
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
1001
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
1010
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
1011
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
1100
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
1101
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
1110
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
1111
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;font-weight: bold;border-right:1px solid;&#34;&gt;
y
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
7
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
6
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
5
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
4
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
3
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
2
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
1
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
0
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
-0
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
-1
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
-2
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
-3
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
-4
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
-5
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
-6
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
-7
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;But the intrigue doesnâ€™t end there! Introducing the 2â€™s Complement Representation, a brilliant method to elegantly incorporate negative numbers. This approach allows us to explore the depths of the negative spectrum, all the way to -8:&lt;/p&gt;
&lt;table class=&#34;table table-striped table-hover&#34; style=&#34;margin-left: auto; margin-right: auto;&#34;&gt;
&lt;caption&gt;
&lt;span id=&#34;tab:unnamed-chunk-7&#34;&gt;Table 3: &lt;/span&gt;2â€™s Complement Representation of numbers from -8 to 7 using 4 bits
&lt;/caption&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;font-weight: bold;border-right:1px solid;&#34;&gt;
bits
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
1000
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
1001
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
1010
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
1011
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
1100
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
1101
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
1110
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
1111
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
0000
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
0001
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
0010
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
0011
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
0100
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
0101
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
0110
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
0111
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;font-weight: bold;border-right:1px solid;&#34;&gt;
y
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
-8
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
-7
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
-6
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
-5
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
-4
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
-3
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
-2
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
-1
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
0
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
1
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
2
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
3
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
4
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
5
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
6
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
7
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;These examples, enriched with R code for hands-on experimentation! ðŸŒŒðŸ’»ðŸš€&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;exploring-further-a-new-perspective-on-integer-representations&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Exploring Further: A New Perspective on Integer Representations&lt;/h1&gt;
&lt;p&gt;Letâ€™s delve deeper into the world of integer representations with a fresh example! Weâ€™ll take a different approach, offering a new perspective to understand and construct binary representations. This time, weâ€™ll focus on a practical application that brings these concepts to life.&lt;/p&gt;
&lt;div id=&#34;example-binary-encoding-of-characters&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Example: Binary Encoding of Characters&lt;/h2&gt;
&lt;p&gt;Imagine you want to represent characters (like letters and symbols) in binary. This is essential in computer science, as it allows for the storage and transmission of text in a form that computers can process. Weâ€™ll use the ASCII (American Standard Code for Information Interchange) system, a widely used method to encode characters.&lt;/p&gt;
&lt;p&gt;Each character in ASCII is assigned a unique number, and this number is then represented in binary. For example, the upper-case letter â€˜Aâ€™ is represented by the number 65 in ASCII, which corresponds to the binary number 01000001.&lt;/p&gt;
&lt;p&gt;Hereâ€™s an R snippet to visualize this transformation for a set of characters:&lt;/p&gt;
&lt;table class=&#34;table table-striped table-hover&#34; style=&#34;margin-left: auto; margin-right: auto;&#34;&gt;
&lt;caption&gt;
&lt;span id=&#34;tab:unnamed-chunk-8&#34;&gt;Table 4: &lt;/span&gt;Binary Encoding of Characters Using ASCII
&lt;/caption&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left;&#34;&gt;
&lt;/th&gt;
&lt;th style=&#34;text-align:left;&#34;&gt;
Char
&lt;/th&gt;
&lt;th style=&#34;text-align:left;&#34;&gt;
ASCII
&lt;/th&gt;
&lt;th style=&#34;text-align:left;&#34;&gt;
Binary
&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;font-weight: bold;border-right:1px solid;&#34;&gt;
A
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
A
&lt;/td&gt;
&lt;td style=&#34;text-align:left;font-family: monospace;&#34;&gt;
41
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
00000000000000000000000001000001
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;font-weight: bold;border-right:1px solid;&#34;&gt;
B
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
B
&lt;/td&gt;
&lt;td style=&#34;text-align:left;font-family: monospace;&#34;&gt;
42
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
00000000000000000000000001000010
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;font-weight: bold;border-right:1px solid;&#34;&gt;
C
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
C
&lt;/td&gt;
&lt;td style=&#34;text-align:left;font-family: monospace;&#34;&gt;
43
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
00000000000000000000000001000011
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;font-weight: bold;border-right:1px solid;&#34;&gt;
D
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
D
&lt;/td&gt;
&lt;td style=&#34;text-align:left;font-family: monospace;&#34;&gt;
44
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
00000000000000000000000001000100
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;font-weight: bold;border-right:1px solid;&#34;&gt;
E
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
E
&lt;/td&gt;
&lt;td style=&#34;text-align:left;font-family: monospace;&#34;&gt;
45
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
00000000000000000000000001000101
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;font-weight: bold;border-right:1px solid;&#34;&gt;
F
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
F
&lt;/td&gt;
&lt;td style=&#34;text-align:left;font-family: monospace;&#34;&gt;
46
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
00000000000000000000000001000110
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;font-weight: bold;border-right:1px solid;&#34;&gt;
G
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
G
&lt;/td&gt;
&lt;td style=&#34;text-align:left;font-family: monospace;&#34;&gt;
47
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
00000000000000000000000001000111
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;font-weight: bold;border-right:1px solid;&#34;&gt;
H
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
H
&lt;/td&gt;
&lt;td style=&#34;text-align:left;font-family: monospace;&#34;&gt;
48
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
00000000000000000000000001001000
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;font-weight: bold;border-right:1px solid;&#34;&gt;
I
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
I
&lt;/td&gt;
&lt;td style=&#34;text-align:left;font-family: monospace;&#34;&gt;
49
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
00000000000000000000000001001001
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left;font-weight: bold;border-right:1px solid;&#34;&gt;
J
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
J
&lt;/td&gt;
&lt;td style=&#34;text-align:left;font-family: monospace;&#34;&gt;
4a
&lt;/td&gt;
&lt;td style=&#34;text-align:left;&#34;&gt;
00000000000000000000000001001010
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;This example shows how characters are converted to ASCII values and then to their binary equivalents, demonstrating the practical application of binary representation in everyday computing tasks. Such an understanding is crucial for tasks like data encoding, cryptography, and digital communication.&lt;/p&gt;
&lt;p&gt;This fresh perspective, combined with hands-on R code, adds another layer to our understanding of binary representations in the digital world. Itâ€™s not just about numbers; itâ€™s about how even the simplest characters we use every day are translated into a language that computers understand. ðŸŒðŸ”¢ðŸ–¥ï¸&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;efficiency-in-data-storage-numbers-vs.-letters&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Efficiency in Data Storage: Numbers vs.Â Letters&lt;/h1&gt;
&lt;p&gt;As we wrap up our exploration of binary representations, itâ€™s crucial to understand why storing numbers instead of letters (words) is often more efficient and preferred in terms of memory usage. This principle is key in optimizing data storage and processing in computing systems.&lt;/p&gt;
&lt;div id=&#34;why-numbers-trump-letters-for-memory-efficiency&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Why Numbers Trump Letters for Memory Efficiency&lt;/h2&gt;
&lt;div id=&#34;compact-representation&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Compact Representation:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Fixed Length&lt;/strong&gt;: Numbers, especially integers, typically have a fixed-length representation in binary. For example, a 32-bit system will represent all integers using 32 bits, regardless of the value. This uniformity leads to more predictable and efficient memory usage.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Greater Density&lt;/strong&gt;: A single number can represent a large range of values. For example, a 32-bit integer can represent over 4 billion different values, while 32 bits allocated for characters might only store a few words.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;processing-speed&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Processing Speed:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Simpler Operations&lt;/strong&gt;: Numerical data allows for more straightforward and faster arithmetic operations compared to string processing, which involves character-by-character manipulation.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Optimized Hardware&lt;/strong&gt;: Computer processors are inherently designed to handle numerical calculations efficiently. Operations on numbers are generally faster due to hardware-level optimizations.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;memory-management&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Memory Management:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Less Overhead&lt;/strong&gt;: Storing numbers reduces the need for additional memory overhead compared to strings. For instance, numbers do not require extra characters for delimiters or markers that are often needed in text.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Indexing and Searching&lt;/strong&gt;: Itâ€™s quicker to index and search through numerical data compared to textual data. This efficiency is crucial in database operations and large-scale data processing.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;application-in-real-world-scenarios&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Application in Real-World Scenarios:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Encoding Complexity&lt;/strong&gt;: Complex data like images, videos, and sound are more efficiently stored and processed as numerical values rather than trying to represent them as lengthy strings of text.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Data Analysis and Machine Learning&lt;/strong&gt;: Numerical data is more amenable to statistical analysis and machine learning algorithms, which rely heavily on numerical inputs for predictions and insights.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In summary, while both numbers and letters have their place in data representation, the choice often boils down to efficiency and suitability for the task at hand. For tasks requiring compact storage, fast processing, and efficient manipulation, numbers usually offer significant advantages over letters or words. This principle of choosing the right data type for the right purpose is fundamental in the field of computer science and data management. ðŸŒðŸ’¾ðŸš€&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;references&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;References&lt;/h1&gt;
&lt;p&gt;Barnett R.; Oâ€™Cull L.; Cox, S. Embedded C Programming and the Microship PIC. Delmar Learning, ed.Â 1, 2004.&lt;/p&gt;
&lt;p&gt;Cadenhead, R.; Liberty, J. Sams Teach Yoirself C++. Pearson Education, ed.Â 6, 2017.&lt;/p&gt;
&lt;p&gt;C Data Types - &lt;a href=&#34;https://en.wikipedia.org/wiki/C_data_types&#34; class=&#34;uri&#34;&gt;https://en.wikipedia.org/wiki/C_data_types&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;citation&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Citation&lt;/h1&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;For attribution, please cite this work as:&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;div-1&#34;&gt;
&lt;p&gt;Oliveira T.P. (2020, Dec.Â 16). Signed and Unsigned Binary Numbers&lt;/p&gt;
&lt;/div&gt;
&lt;ol start=&#34;2&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;BibTeX citation&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;@misc{oliveira2020signed,
  author = {Oliveira, Thiago},
  title = {Signed and Unsigned Binary Numbers},
  url = {https://prof-thiagooliveira.netlify.app/post/signed-and-unsigned-binary-numbers/},
  year = {2020}
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Did you find this page helpful? Consider sharing it ðŸ™Œ&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>
